---
title: "WGCNA with blockwise modules and V1 of Mcap genome"
author: "Ariana S Huffmyer"
date: "3/14/2022"
output: html_document
editor_options: 
  chunk_output_type: console
---

WGCNA analysis of TagSeq dataset across *M. capitata* lifestages in developmental time series collected in Hawaii in 2020. These scripts are based on scripts from Erin Chille's master's thesis at the University of Rhode Island (https://github.com/echille).  

This script conducts WGCNA and DEG analysis of TagSeq data set using version 1 of the *M. capitata* genome made available through Rutgers (http://cyanophora.rutgers.edu/montipora/) using `blockwiseModules` rather than `dynamicTreeCut`.  

# Pipeline Overview

1. Data preparation
  + Load and format gene count matrix and align metadata
  + Data filtering: PoverA and genefilter
  + Outlier detection
2. Generate DESeq object 
3. View PCA and heatmap of samples


4. Network construction and consensus module detection
  + Examine outliers 
  + Choosing a soft-thresholding power: Analysis of a network topology β  
  + Identify modules using blockwiseModules 
  
  
  + Relate modules to sample information  
  + Relate modules to life stage
  
  
  
3. Plot module-trait associations
4. Plot mean eigengene values for each module  
5. Pathway analysis 

# **Load libraries**  
```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# The following setting is important, do not omit.
options(stringsAsFactors = FALSE) #Set Strings to character
```

Load required libraries.  

```{r}
if ("tidyverse" %in% rownames(installed.packages()) == 'FALSE') install.packages('tidyverse') 
if ("genefilter" %in% rownames(installed.packages()) == 'FALSE') install.packages('genefilter') 
if ("DESeq2" %in% rownames(installed.packages()) == 'FALSE') install.packages('DESeq2') 
if ("RColorBrewer" %in% rownames(installed.packages()) == 'FALSE') install.packages('RColorBrewer') 
if ("WGCNA" %in% rownames(installed.packages()) == 'FALSE') install.packages('WGCNA') 
if ("flashClust" %in% rownames(installed.packages()) == 'FALSE') install.packages('flashClust') 
if ("gridExtra" %in% rownames(installed.packages()) == 'FALSE') install.packages('gridExtra') 
if ("ComplexHeatmap" %in% rownames(installed.packages()) == 'FALSE') install.packages('ComplexHeatmap') 
if ("goseq" %in% rownames(installed.packages()) == 'FALSE') install.packages('goseq') 
if ("dplyr" %in% rownames(installed.packages()) == 'FALSE') install.packages('dplyr') 
if ("clusterProfiler" %in% rownames(installed.packages()) == 'FALSE') install.packages('clusterProfiler') 
if ("pheatmap" %in% rownames(installed.packages()) == 'FALSE') install.packages('pheatmap') 
if ("magrittr" %in% rownames(installed.packages()) == 'FALSE') install.packages('magrittr') 

library("tidyverse")
library("genefilter")
library("DESeq2")
library("RColorBrewer")
library("WGCNA")
library("flashClust")
library("gridExtra")
library("ComplexHeatmap")
library("goseq")
library("dplyr")
library("clusterProfiler")
library("pheatmap")
library("magrittr")
library("dendsort")

```

# **1. Data input and filtering**  
 
Import the data files.  

```{r}
#load metadata sheet with sample name and developmental stage information
metadata <- read.csv("Mcap2020/Data/TagSeq/Sample_Info.csv", header = TRUE, sep = ",")
head(metadata)

#load gene count matrix generated from cluster computation
gcount <- as.data.frame(read.csv("Mcap2020/Output/TagSeq/Mcapitata_gene_count_matrix.csv", row.names="gene_id"), colClasses = double)
head(gcount)

#remove metamorphosed recruit 1 because this was the timepoint that we only had one sample for: D36, AH23
gcount<-gcount[ , !(names(gcount) %in% c("AH23_S54_L002.gtf"))]

metadata <- metadata%>%
  filter(!sample_id=="AH23")
```

Check that there are no genes with 0 counts across all samples. 

```{r}
nrow(gcount)

gcount<-gcount %>%
     mutate(Total = rowSums(.[, 1:38]))%>%
    filter(!Total==0)%>%
    select(!Total)

nrow(gcount)
```
There were about 15,000 genes that had 0 across all rows. These were removed. We now have 39,459 genes out of 63,227 genes.      

Conduct data filtering, this includes:  

*pOverA*: Specifying the minimum count for a proportion of samples for each gene. Here, we are using a pOverA of 0.07. This is because we have 38 samples with a minimum of n=3 samples per lifestage. Therefore, we will accept genes that are present in 3/38 = 0.07 of the samples because we expect different expression by life stage. We are further setting the minimum count of genes to 10, such that 7% of the samples must have a gene count of >10 in order for the gene to remain in the data set.  

Filter in the package "genefilter". Pre-filtering our dataset to reduce the memory size dataframe, increase the speed of the transformation and testing functions, and improve quality of statistical analysis by removing low-coverage counts. Removed counts could represent outliers in the data and removing these improves sensitivity of statistical tests.   

```{r}
filt <- filterfun(pOverA(0.07,10))

#create filter for the counts data
gfilt <- genefilter(gcount, filt)

#identify genes to keep by count filter
gkeep <- gcount[gfilt,]

#identify genes to keep by count filter
gkeep <- gcount[gfilt,]

#identify gene lists
gn.keep <- rownames(gkeep)

#gene count data filtered in PoverA, P percent of the samples have counts over A
gcount_filt <- as.data.frame(gcount[which(rownames(gcount) %in% gn.keep),])

#How many rows do we have before and after filtering?
nrow(gcount) #Before
nrow(gcount_filt) #After
```

Before filtering, we had approximately 39,000 genes. After filtering for pOverA, we have approximately 12,200 genes. This indicates that there were many low count genes present in <7% of samples at <10 counts per gene.  

In order for the DESeq2 algorithms to work, the SampleIDs on the metadata file and count matrices have to match exactly and in the same order. 

Match metadata sample id's.  
```{r}
result<-sub("_.*", "", colnames(gcount_filt)) #keep characters before _
#result2<-sub(".*AH", "", result) #keep characters after X
colnames(gcount_filt)<-result #keep just sample number 
```

Order metadata the same as the column order in the gene matrix.  
```{r}
list<-colnames(gcount_filt)
list<-as.factor(list)

metadata$sample_id<-as.factor(metadata$sample_id)

# Re-order the levels
metadata$sample_id <- factor( as.character(metadata$sample_id), levels=list)
# Re-order the data.frame
metadata_ordered <- metadata[order(metadata$sample_id),]
metadata_ordered$sample_id

metadata_ordered<-metadata_ordered%>%
  select(sample_id, lifestage, hpf, code)
```

# **2. Construct DESeq2 data set**  

Create a DESeqDataSet design from gene count matrix and labels. Here we set the design to look at lifestage to test for any differences in gene expression across timepoints.  
```{r}
#Set DESeq2 design
gdds <- DESeqDataSetFromMatrix(countData = gcount_filt,
                              colData = metadata_ordered,
                              design = ~lifestage)
```

First we are going to log-transform the data using a variance stabilizing transforamtion (VST). This is only for visualization purposes. Essentially, this is roughly similar to putting the data on the log2 scale. It will deal with the sampling variability of low counts by calculating within-group variability (if blind=FALSE). Importantly, it does not use the design to remove variation in the data, and so can be used to examine if there may be any variability do to technical factors such as extraction batch effects.

To do this we first need to calculate the size factors of our samples. This is a rough estimate of how many reads each sample contains compared to the others. In order to use VST (the faster log2 transforming process) to log-transform our data, the size factors need to be less than 4.

Chunk should return TRUE if <4.  
```{r}
SF.gdds <- estimateSizeFactors(gdds) #estimate size factors to determine if we can use vst  to transform our data. Size factors should be less than 4 for us to use vst
print(sizeFactors(SF.gdds)) #View size factors

all(sizeFactors(SF.gdds)) < 4
```

All size factors are less than 4, so we can use VST transformation.  

```{r}
gvst <- vst(gdds, blind=FALSE) #apply a variance stabilizing transforamtion to minimize effects of small counts and normalize wrt library size
head(assay(gvst), 3) #view transformed gene count data for the first three genes in the dataset.  
```

# **3. Examine PCA and sample distances**  

Plot a heatmap to sample to sample distances  

```{r}
gsampleDists <- dist(t(assay(gvst))) #calculate distance matix
gsampleDistMatrix <- as.matrix(gsampleDists) #distance matrix
rownames(gsampleDistMatrix) <- colnames(gvst) #assign row names
colnames(gsampleDistMatrix) <- NULL #assign col names
colors <- colorRampPalette( rev(brewer.pal(9, "Blues")) )(255) #assign colors

save_pheatmap_pdf <- function(x, filename, width=7, height=7) {
   stopifnot(!missing(x))
   stopifnot(!missing(filename))
   pdf(filename, width=width, height=height)
   grid::grid.newpage()
   grid::grid.draw(x$gtable)
   dev.off()
}

pht<-pheatmap(gsampleDistMatrix, #plot matrix
         clustering_distance_rows=gsampleDists, #cluster rows
         clustering_distance_cols=gsampleDists, #cluster columns
         col=colors) #set colors

save_pheatmap_pdf(pht, "Mcap2020/Figures/TagSeq/BlockwiseV1/pheatmap.pdf")
```

Plot a PCA of samples by lifestages.    

```{r}
gPCAdata <- plotPCA(gvst, intgroup = c("lifestage"), returnData=TRUE)
percentVar <- round(100*attr(gPCAdata, "percentVar")) #plot PCA of samples with all data

allgenesfilt_PCA <- ggplot(gPCAdata, aes(PC1, PC2, shape=lifestage)) + 
  geom_point(size=3) +
  xlab(paste0("PC1: ",percentVar[1],"% variance")) +
  ylab(paste0("PC2: ",percentVar[2],"% variance")) +
  scale_shape_manual(values = c("1_Egg"=17, "10_CalcifyingRecruit2"=1, "2_Embryo"=10, "3_Larvae1"=5, "4_Larvae2"=14, "5_Larvae3"=11, "6_Larvae4"=6, "7_Larvae6"=2, "8_MetamorposedRecruit2"=8, "9_CalcifyingRecruit1"=3)) +
  #xlim(-40,40)+ 
  #ylim(-40,40)+
  coord_fixed()+
  theme_bw() + #Set background color
  theme(panel.border = element_blank(), # Set border
                     #panel.grid.major = element_blank(), #Set major gridlines 
                     #panel.grid.minor = element_blank(), #Set minor gridlines
                     axis.line = element_line(colour = "black"), #Set axes color
        plot.background=element_blank()) # + #Set the plot background
  #theme(legend.position = ("none")) #set title attributes
allgenesfilt_PCA
ggsave("Mcap2020/Figures/TagSeq/BlockwiseV1/allgenesfilt-PCA.pdf", allgenesfilt_PCA, width=11, height=8)
```

We still have strong life stage groupings with the new reference genome.   

# **4. Network construction and consensus module detection**  

## Examine outliers  

Transpose the filtered gene count matrix so that the gene IDs are rows and the sample IDs are columns.
```{r}
datExpr <- as.data.frame(t(assay(gvst))) #transpose to output to a new data frame with the column names as row names. And make all data numeric
```

Check for genes and samples with too many missing values with goodSamplesGenes. There shouldn't be any because we performed pre-filtering. Code should return TRUE.  
```{r}
gsg = goodSamplesGenes(datExpr, verbose = 3)
gsg$allOK #Should return TRUE if not, the R chunk below will take care of flagged data
```

Look for outliers by examining a tree of samples.    
```{r}
sampleTree = hclust(dist(datExpr), method = "average");
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
# The user should change the dimensions if the window is too large or too small.
pdf("Mcap2020/Figures/TagSeq/BlockwiseV1/outliers.pdf")
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)
dev.off()
```
There don't look to be any outliers, so we will move on with business as usual.  

## Choosing a soft-thresholding power: Analysis of network topology β  

The soft thresholding power (β) is the number to which the co-expression similarity is raised to calculate adjacency. The function pickSoftThreshold performs a network topology analysis. The user chooses a set of candidate powers, however the default parameters are suitable values.  
```{r, message=FALSE, warning=FALSE}
allowWGCNAThreads()
# # Choose a set of soft-thresholding powers
powers <- c(seq(from = 1, to=19, by=2), c(21:30)) #Create a string of numbers from 1 through 10, and even numbers from 10 through 20
# 
# # Call the network topology analysis function
sft <-pickSoftThreshold(datExpr, powerVector = powers, verbose = 5)
```

Plot the results.  
```{r}
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# # # Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
      xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
 text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# # # this line corresponds to using an R^2 cut-off
 abline(h=0.9,col="red")
# # # Mean connectivity as a function of the soft-thresholding power
 plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
 text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
```
I used a scale-free topology fit index **R^2 of 0.9**. This lowest recommended R^2 by Langfelder and Horvath is 0.8. I chose 0.9 because we want to use the smallest soft thresholding power that maximizes with model fit. It appears that our **soft thresholding power is 7** because it is the lowest power after the R^2=0.9 threshold that maximizes with model fit.  

## Identify modules using blockwiseModules  

We will use blockwiseModules to identify modules of genes. We use a single block for this analysis. 

We will use a signed network with deepSplit=2 (this value ranges from 0-4 with 4 being most sensitive and 1 being least sensitive). We will use a detect cut height of 0.95, a minimum module size of 20, and a merge cut height of 0.15, which will merge modules with 85% similarity.  

``` {r, echo=TRUE, warning=FALSE, message=FALSE}

picked_power = 7
temp_cor <- cor       
cor <- WGCNA::cor                                             # Force it to use WGCNA cor function (fix a namespace conflict issue)
netwk <- blockwiseModules(datExpr,                            # <= input here

                          # == Adjacency Function ==
                          power = picked_power,               # <= power here
                          networkType = "signed",             # network type (signed or unsigned)

                          # == Tree and Block Options ==
                          deepSplit = 2,
                          pamStage=FALSE,
                          pamRespectsDendro = F,
                          detectCutHeight = 0.99, 
                          minModuleSize = 20,                   #minimum size of module (# genes)
                          maxBlockSize = 14000,                 #maximum size of blocks (analyze all in one block)
                          
                           # == Gene reassignment, module trimming, and module "significance" criteria (not used with 1 block) ==

                          #reassignThreshold = 1e-6,            #p-value for gene reassignment
                          #minCoreKME = 0.5,                    #minimum module membership score 
                          #minCoreKMESize = 6,
                          #minKMEtoStay = 0.3,

                          # == Module Adjustments ==
                          #reassignThreshold = 0,
                          mergeCutHeight = 0.15,               #merge 85% similar modules

                          # == TOM == Archive the run results in TOM file (saves time) but it doesn't save a file
                          saveTOMs = F,
                          saveTOMFileBase = "ER",
                          
                          # == Output Options
                          numericLabels = T,                   #use numeric labels for modules rather than colors 
                          verbose = 5)

cor <- temp_cor     # Return cor function to original namespace

# Identify labels as numbers 
mergedColors = netwk$colors

# Plot the dendrogram and the module colors underneath

pdf("Mcap2020/Figures/TagSeq/BlockwiseV1/blockwise_module_colors.pdf")
plotDendroAndColors(
  netwk$dendrograms[[1]],
  mergedColors[netwk$blockGenes[[1]]],
  "Module colors",
  dendroLabels = FALSE,
  hang = 0.03,
  addGuide = TRUE,
  guideHang = 0.05 )
dev.off()
```

Now view the number of genes in each module detected.  
```{r}
table(mergedColors)
```

deepSplit=2 + softpower=5  
mergedColors
   0    1    2    3    4    5    6    7    8 
4924 3520 1601  702  698  325  253  110  104 

deepSplit=2 + softpower=7 
mergedColors
   0    1    2    3    4    5    6    7    8    9 
4373 3239 2104  744  591  494  369  195   88   40 

deepSplit=3 + softpower=7 
mergedColors
   0    1    2    3    4    5    6    7    8    9   10   11 
6208 3206 1461  316  262  228  188  173   88   42   39   26 

deepSplit=2 + softpower=7 + minModule=20 (Keep at 20)
mergedColors
   0    1    2    3    4    5    6    7    8    9 
4373 3239 2104  744  591  494  369  195   88   40 

deepSplit=2 + softpower=7 + mergecutheight=0.2  (keep at 0.15)
mergedColors
   0    1    2    3    4    5    6    7    8 
4373 3239 2104 1085  744  369  195   88   40 

deepSplit=2 + softpower=7 + detectCutHeight=0.9 
mergedColors
   0    1    2    3    4    5    6    7    8    9 
4953 3206 2096  583  368  300  265  228  150   88 

deepSplit=2 + softpower=7 + detectCutHeight=0.98 
mergedColors
   0    1    2    3    4    5    6    7    8    9   10 
4226 3239 1907  744  702  503  369  203  195  109   40 

deepSplit=2 + softpower=7 + detectCutHeight=0.99 (keep at 0.99)
mergedColors
   0    1    2    3    4    5    6    7    8    9   10 
4226 3239 1907  744  702  503  369  203  195  109   40 

deepSplit=2 + softpower=7 + detectCutHeight=0.99 + pamstage=T
mergedColors
   0    1    2    3    4    5    6    7    8    9 
 993 3408 3406 1508 1302  772  489  196  112   51 

deepSplit=2 + softpower=7 + detectCutHeight=0.99 + pamstage=T + pamrespectsdendro=T (try keeping these)
mergedColors
   0    1    2    3    4    5    6    7    8    9 
1034 3413 3407 1453 1319  749  471  224  111   56 

deepSplit=2 + softpower=7 + detectCutHeight=0.99 + pamstage=T + pamrespectsdendro=T +mergecutheight=0.75
mergedColors
   0    1    2    3    4    5    6    7    8 
1034 3413 3407 1453 1319  749  695  111   56 

## Relate modules to sample information  

``` {r, echo=TRUE, warning=FALSE, message=FALSE}
module_df <- data.frame(
  Gene = names(netwk$colors),
  module = netwk$colors
  #colors = labels2colors(netwk$colors)
)

module_df[1:5,]

write.csv(module_df, "Mcap2020/Output/TagSeq/BlockwiseV1/gene_modules.csv")

# Get Module Eigengenes per cluster
MEs <- moduleEigengenes(datExpr, mergedColors)$eigengenes

# Reorder modules so similar modules are next to each other
MEs <- orderMEs(MEs)
module_order = names(MEs) %>% gsub("ME","", .)

# Add Sample names
MEs0 <- MEs
MEs0$Sample.ID = row.names(MEs)

# tidy & plot data
mME = MEs0 %>%
  pivot_longer(-Sample.ID) %>%
  mutate(
    name = gsub("ME", "", name),
    name = factor(name, levels = module_order)
  )

mME %>% ggplot(., aes(x=Sample.ID, y=name, fill=value)) +
  geom_tile() +
  theme_bw() +
  scale_fill_gradient2(
    low = "blue",
    high = "red",
    mid = "white",
    midpoint = 0,
    limit = c(-1,1)) +
  theme(axis.text.x = element_text(angle=90)) +
  labs(title = "Module-Sample Relationships", y = "Modules", fill="corr")
```

## Relate modules to life stage  

Prepare trait data. Data has to be numeric, so I will substitute time points/developmental stages for numeric values. The "trait" we are considering here is lifestage. Make a dataframe that has a column for each lifestage name and a row for samples. Populate a 1 for samples that match each lifestage and a 0 for samples not matching respective lifestages. This process changes lifestages from a categorical variable into a binary variable. This will allow for correlations between mean eigengenes and lifestage.  
 
```{r}
metadata$num <- c("1")
allTraits <- as.data.frame(pivot_wider(metadata, names_from = lifestage, values_from = num, id_cols = sample_id))
allTraits[is.na(allTraits)] <- c("0")
rownames(allTraits) <- allTraits$Sample
datTraits <- allTraits[,c(-1)]
head(datTraits)

#define numbers of metabolites and samples and view 
nGenes = ncol(datExpr)
nSamples = nrow(datExpr)

nGenes
nSamples
```

We have 12,237 genes and 38 samples.   

Next correlate the trait of life stage with eigengenes (modules).  

```{r}
# Correlations of traits with eigengenes
moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);
Colors=sub("ME","", names(MEs))
moduleTraitTree = hclust(dist(t(moduleTraitCor)), method = "average")
pdf(file="Mcap2020/Figures/TagSeq/BlockwiseV1/ModuleTraitClusterTree.pdf", height=8, width=22)
plot(moduleTraitTree)
dev.off()

# Correlations of metabolites with eigengenes. Calculate correlations between ME's and groups 
moduleGeneCor=cor(MEs,datExpr)
moduleGenePvalue = corPvalueStudent(moduleGeneCor, nSamples);
head(moduleGenePvalue)
```

## Plot module-trait associations

Represent module trait correlations as a heatmap.  
```{r, echo=TRUE, warning=FALSE, message=FALSE}
textMatrix = paste(signif(moduleTraitCor, 2), "\n(",signif(moduleTraitPvalue, 1), ")", sep = "")
dim(textMatrix) = dim(moduleTraitCor)
head(textMatrix)
labeledHeatmap(Matrix = moduleTraitCor, xLabels = names(datTraits),  yLabels = names(MEs), ySymbols = names(MEs), cex.lab.y= 0.55, cex.lab.x= 0.55, colors = blueWhiteRed(50), textMatrix = textMatrix, setStdMargins = TRUE, cex.text = 0.25, textAdj = , zlim = c(-1,1), main = paste("Module-trait relationships"))
pdf(file="Mcap2020/Figures/TagSeq/BlockwiseV1/Module-trait-relationships.pdf")
labeledHeatmap(Matrix = moduleTraitCor, xLabels = names(datTraits),  yLabels = names(MEs), ySymbols = names(MEs), cex.lab.y= 0.55, cex.lab.x= 0.55, colors = blueWhiteRed(50), textMatrix = textMatrix, setStdMargins = TRUE, cex.text = 0.25, textAdj = , zlim = c(-1,1), main = paste("Module-trait relationships"))
dev.off()

```


# **5. Plot module trait associations with a complex heatmap**     

```{r, echo=TRUE, warning=FALSE, message=FALSE}
#bold sig p-values
#dendrogram with WGCNA MEtree cut-off
#colored y-axis
#Create list of pvalues for eigengene correlation with specific life stages
heatmappval <- signif(moduleTraitPvalue, 1)
#Make list of heatmap row colors
htmap.colors <- names(MEs)
htmap.colors <- gsub("ME", "", htmap.colors)

row_dend = dendsort(hclust(dist(moduleTraitCor)))
col_dend = dendsort(hclust(dist(t(moduleTraitCor))))


#row_ha = rowAnnotation(ModuleSize = anno_text("11", "127", "8", "64", "85"), just = "left", 
#        location = unit(0.5, "npc"), show_name = TRUE)
# brown (11), grey (127), yellow (8), blue (64), turqoise (85) #figure out how to do row annotations to add sample sizes

pdf(file = "Mcap2020/Figures/TagSeq/BlockwiseV1/Module-trait-relationship-heatmap.pdf", height = 8, width = 8)
ht=Heatmap(moduleTraitCor, name = "Eigengene", column_title = "Module-Group Eigengene Correlation", 
        col = blueWhiteRed(50), 
        row_names_side = "left", 
        row_dend_side = "left",
        width = unit(5, "in"), 
        height = unit(4.5, "in"), 
        column_dend_reorder = TRUE, 
        cluster_columns = col_dend,
        row_dend_reorder = FALSE,
        column_split = 4, 
        row_split = 4, 
        column_dend_height = unit(.5, "in"),
        cluster_rows = row_dend, 
        row_gap = unit(2.5, "mm"), 
        border = TRUE,
        cell_fun = function(j, i, x, y, w, h, col) {
        if(heatmappval[i, j] < 0.05) {
            grid.text(sprintf("%s", heatmappval[i, j]), x, y, gp = gpar(fontsize = 10, fontface = "bold"))
        }
        else {
            grid.text(sprintf("%s", heatmappval[i, j]), x, y, gp = gpar(fontsize = 10, fontface = "plain"))
        }},
        column_names_gp =  gpar(fontsize = 12, border=FALSE),
        row_names_gp = gpar(fontsize = 12, alpha = 0.75, border = FALSE))
draw(ht)
dev.off()
```





























# 4. Plot mean eigengene values for each module

Load metadata and plot expression plots.  
```{r, echo=TRUE, warning=FALSE, message=FALSE}

# Number of each metabolites in each module 
row_mod_num <- data.frame(table(module_df$colors)) 


# Bring in additional metadata

sample_metadata <- read.csv("Mcap2020/Data/Metabolomics/metabolomics_meta_wgcna.csv") 

sample_metadata$Sample.ID <- as.factor(sample_metadata$Sample.ID)
sample_metadata$lifestage <- as.factor(sample_metadata$lifestage)
sample_metadata$hpf <- as.factor(sample_metadata$hpf)
sample_metadata$group <- as.factor(sample_metadata$group)

mME_meta <- merge(mME, sample_metadata, by = "Sample.ID") %>%
  rename(Module = name)
```

Add module "cluster" categories determined by WGCNA above.  
```{r}
mME_meta<-mME_meta%>%
  mutate(Cluster=if_else(Module == "2", "Cluster1", 
                               if_else(Module =="5", "Cluster1", 
                                       if_else(Module == "0", "Cluster1", 
                                               if_else(Module == "7", "Cluster2",
                                               if_else(Module=="6", "Cluster2", 
                                                       if_else(Module == "3", "Cluster2", 
                                                       if_else(Module == "1", "Cluster3", 
                                                               if_else(Module == "8", "Cluster3",
                                                               if_else(Module == "4", "Cluster3", "NA"))))))))))

mME_meta$Cluster<-as.factor(mME_meta$Cluster)
```


Plot by time point with individual modules.  
```{r}

mME_meta$group <- factor(mME_meta$group, levels = c("Egg", "Embryo", "Larvae", "Metamorphosed Recruit", "Attached Recruit"))
mME_meta$Module <- factor(mME_meta$Module, levels = c("0", "1", "2", "3", "4", "5", "6", "7", "8"))

expression_plots<-mME_meta%>%
#  group_by(Module) %>%
  ggplot(aes(x=hpf, y=value, fill=group)) +
  facet_wrap(~ Module)+
  ylab("Mean Module Eigenegene Value") +
  geom_hline(yintercept = 0, linetype="dashed", color = "grey")+
  geom_boxplot(width=.5, outlier.shape= NA, position = position_dodge(width = 0.5), alpha = 0.7) +
  stat_summary(fun=mean, geom="line", aes(group=lifestage, color = group), position = position_dodge(width = 0.5))  + 
  geom_point(pch = 21, position = position_dodge(width = 0.5)) +
  scale_fill_manual(name="Lifestage", values=c("#8C510A", "#DFC27D","#80CDC1", "#003C30", "#BA55D3")) +
  scale_color_manual(name="Lifestage", values=c("#8C510A", "#DFC27D","#80CDC1", "#003C30", "#BA55D3")) + 
  xlab("Hours Post-Fertilization") + #Axis titles
  theme_bw() + theme(panel.border = element_rect(color="black", fill=NA, size=0.75), panel.grid.major = element_blank(), #Makes background theme white
                     panel.grid.minor = element_blank(), axis.line = element_blank()) +
  theme(axis.text = element_text(size = 11 , color = "black"),
        axis.title = element_text(size = 16, color = "black"), 
        axis.text.x = element_text(size=11, color="black"), 
        legend.title=element_blank(), 
        legend.text=element_text(color="black", size=12)); expression_plots

ggsave(filename="Mcap2020/Figures/Metabolomics/WGCNA/expression_eigengene.jpeg", plot=expression_plots, dpi=300, width=12, height=8, units="in")

head(mME_meta)

```

Output eigengene values to a data frame.  

```{r}
write.csv(mME_meta, "Mcap2020/Output/Metabolomics/WGCNA/module_expression.csv")
```

Plot by time point with module clusters.  
```{r}
#mME_meta$group <- factor(mME_meta$group, levels = c("Egg", "Embryo", "Larvae", "Metamorphosed Recruit", "Attached Recruit"))
#mME_meta$Cluster <- factor(mME_meta$Cluster, levels = c("Cluster1", "Cluster2", "Cluster3"))

expression_plots_cluster<-mME_meta%>%
#  group_by(Module) %>%
  ggplot(aes(x=hpf, y=value, fill=group)) +
  facet_grid(Cluster ~.)+
  ylab("Mean Module Cluster Eigenegene Value") +
  geom_hline(yintercept = 0, linetype="dashed", color = "grey")+
  geom_boxplot(width=.5, outlier.shape= NA, position = position_dodge(width = 0.5), alpha = 0.7) +
  stat_summary(fun=mean, geom="line", aes(group=lifestage, color = group), position = position_dodge(width = 0.5))  + 
  geom_point(pch = 21, position = position_dodge(width = 0.5)) +
  scale_fill_manual(name="Lifestage", values=c("#8C510A", "#DFC27D","#80CDC1", "#003C30", "#BA55D3")) +
  scale_color_manual(name="Lifestage", values=c("#8C510A", "#DFC27D","#80CDC1", "#003C30", "#BA55D3")) + 
  xlab("Hours Post-Fertilization") + #Axis titles
  theme_bw() + theme(panel.border = element_rect(color="black", fill=NA, size=0.75), panel.grid.major = element_blank(), #Makes background theme white
                     panel.grid.minor = element_blank(), axis.line = element_blank()) +
  theme(axis.text = element_text(size = 11 , color = "black"),
        axis.title = element_text(size = 16, color = "black"), 
        axis.text.x = element_text(size=11, color="black"), 
        legend.position="top", 
        legend.title=element_blank(), 
        legend.text=element_text(color="black", size=12), 
        strip.text.y = element_text(size = 14, color = "black", face = "bold.italic")); expression_plots_cluster

ggsave(filename="Mcap2020/Figures/Metabolomics/WGCNA/expression_eigengene_cluster.jpeg", plot=expression_plots_cluster, dpi=300, width=7, height=10, units="in")

``` 
















## Co-expression adjacency and topological overlap matrix similarity  

Adjacency and TOMsimilarity will be executed in supercomputer, Bluewaves, as our dataset is too large for most standard laptops to handle.

Save Rdata necessary for analysis
```{r}
save(datExpr, file = "Mcap2020/Output/TagSeq/BlockwiseV1/datExpr.RData")
```

Co-expression similarity and adjacency, using the soft thresholding power 7 and translate the adjacency into topological overlap matrix to calculate the corresponding dissimilarity. I will use a **signed network**: https://peterlangfelder.com/2018/11/25/__trashed/
```{r, }
# #Set up workspace
#getwd() #Display the current working directory
# #If necessary, change the path below to the directory where the data files are stored. "." means current directory. On Windows use a forward slash / instead of the usual \.
#workingDir = ".";
# setwd(WGCNA_dev);
# library(WGCNA) #Load the WGCNA package
options(stringsAsFactors = FALSE) #The following setting is important, do not omit.
enableWGCNAThreads() #Allow multi-threading within WGCNA. 
# 
# #Load the data saved in the first part
adjTOM <- load(file="Mcap2020/Output/TagSeq/BlockwiseV1/datExpr.RData")
adjTOM
# 
# #Run analysis
softPower=7 #Set softPower to 5
adjacency=adjacency(datExpr, power=softPower,type="signed") #Calculate adjacency

TOM= TOMsimilarity(adjacency,TOMType = "signed") #Translate adjacency into topological overlap matrix
#this step can take awhile 

dissTOM= 1-TOM #Calculate dissimilarity in TOM

save(adjacency, TOM, dissTOM, file = "Mcap2020/Output/TagSeq/BlockwiseV1/adjTOM.RData") #Save 

save(dissTOM, file = "Mcap2020/Output/TagSeq/BlockwiseV1/dissTOM.RData") #Save 
```

Load in dissTOM file obtained from previous R chunk.    
```{r}
dissTOM_in <- load(file="Mcap2020/Output/TagSeq/BlockwiseV1/dissTOM.RData") 
dissTOM_in
```

### Clustering using TOM

Form distance matrix
```{r}
geneTree= flashClust(as.dist(dissTOM), method="average")
```

We will now plot a dendrogram of genes. Each leaf corresponds to a gene, branches grouping together densely are interconnected, highly co-expressed genes.
```{r}
pdf(file="Mcap2020/Figures/TagSeq/dissTOMClustering.pdf", width=20, height=20)
plot(geneTree, xlab="", sub="", main= "Gene Clustering on TOM-based dissimilarity", labels= FALSE,hang=0.04)
dev.off()
```

### Module identification using dynamicTreeCut  

Module identification is essentially cutting the branches off the tree in the dendrogram above. We like large modules, so we set the **minimum module size** relatively high, so we will set the minimum size at 30. I chose 30 as it is the default value chosen by most studies using WGCNA. 

```{r}
minModuleSize = 30
dynamicMods = cutreeDynamic(dendro = geneTree, distM = dissTOM,
deepSplit = 2, pamRespectsDendro = FALSE,
minClusterSize = minModuleSize)
table(dynamicMods) #list modules and respective sizes
save(dynamicMods, geneTree, file = "Mcap2020/Output/TagSeq/dyMod_geneTree.RData") #Save to load into RStudio
```
Module 0 is reserved for unassigned genes. The are other modules will be listed largest to smallest.

Load modules calculated from the adjacency matrix.  
```{r}
dyMod_geneTree <- load(file = "Mcap2020/Output/TagSeq/dyMod_geneTree.RData")
dyMod_geneTree
```

Plot the module assignment under the gene dendrogram
```{r}
#dynamicColors = labels2colors(dynamicMods) # Convert numeric labels into colors
dynamicColors=dynamicMods
table(dynamicColors)

pdf(file="Mcap2020/Figures/TagSeq/dissTOMColorClustering.pdf", width=20, height=20)
plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut", dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05, main = "Gene dendrogram and module colors")
dev.off()
```

### Merge modules with similar expression profiles  

Plot module similarity based on eigengene value 
```{r}
#Calculate eigengenes
MEList = moduleEigengenes(datExpr, colors = dynamicColors, softPower = 5)
MEs = MEList$eigengenes

#Calculate dissimilarity of module eigengenes
MEDiss = 1-cor(MEs)

#Cluster again and plot the results
METree = flashClust(as.dist(MEDiss), method = "average")

pdf(file="Mcap2020/Figures/TagSeq/eigengeneClustering1.pdf", width = 20)
plot(METree, main = "Clustering of module eigengenes", xlab = "", sub = "")
dev.off()
```

**Merge modules with >85% eigengene similarity.** Most studies use somewhere between 80-90% similarity. It looks like most of our modules are highly related so I will use 85% similarity as my merging threshold.
```{r}
MEDissThres= 0.15 #merge modules that are 85% similar

pdf(file="Mcap2020/Figures/TagSeq/eigengeneClustering2.pdf", width = 20)
plot(METree, main = "Clustering of module eigengenes", xlab = "", sub = "")
abline(h=MEDissThres, col="red")
dev.off()

merge= mergeCloseModules(datExpr, dynamicColors, cutHeight= MEDissThres, verbose =3)

mergedColors= merge$colors
mergedMEs= merge$newMEs

pdf(file="Mcap2020/Figures/TagSeq/mergedClusters.pdf", width=20, height=20)
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors), c("Dynamic Tree Cut", "Merged dynamic"), dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang=0.05)
dev.off()
```

There are 9 modules before merging with 85% similarity.  

Save new colors
```{r}
moduleLabels=mergedColors
moduleColors = mergedColors # Rename to moduleColors
#colorOrder = c("grey", standardColors(50)); # Construct numerical labels corresponding to the colors
#moduleLabels = match(moduleColors, colorOrder)-1;
MEs = mergedMEs;
ncol(MEs) #How many modules do we have now?
```

We have 8 modules after merging with 85% similarity.   

Plot new tree with 8 modules.  
```{r}
#Calculate dissimilarity of module eigengenes
MEDiss = 1-cor(MEs)
#Cluster again and plot the results
pdf(file="Mcap2020/Figures/TagSeq/eigengeneClustering3.pdf")
METree = flashClust(as.dist(MEDiss), method = "average")
MEtreePlot = plot(METree, main = "Clustering of module eigengenes", xlab = "", sub = "")
dev.off()
```

##  Relating modules to developmental stage

### Quantifying module–trait associations

Prepare trait data. Data has to be numeric, so I will substitute time_points and type for numeric values. The "trait" we are considering here is ontogeny.  

Make a dataframe that has a column for each lifestage name and a row for samples. Populate a 1 for samples that match each lifestage and a 0 for samples not matching respective lifestages. 

This process changes lifestages from a categorical variable into a binary variable. This will allow for correlations between mean eigengenes and lifestage.  
 
```{r}
metadata$num <- c("1")
allTraits <- as.data.frame(pivot_wider(metadata, names_from = lifestage, values_from = num, id_cols = sample_id))
allTraits[is.na(allTraits)] <- c("0")
rownames(allTraits) <- allTraits$sample_id
datTraits <- allTraits[,c(-1)]
datTraits
```

Define numbers of genes and samples and print.  
```{r}
nGenes = ncol(datExpr)
nSamples = nrow(datExpr)

nGenes
nSamples
```

We have 12,237 genes and 38 samples.  

Generate labels for module eigengenes as numbers.  
```{r}
MEs0 = moduleEigengenes(datExpr, moduleLabels,softPower=5)$eigengenes
MEs = orderMEs(MEs0)
names(MEs)
```

Correlations of traits with eigengenes
```{r}
moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);
Colors=sub("ME","", names(MEs))

moduleTraitTree = hclust(dist(t(moduleTraitCor)), method = "average")

pdf(file="Mcap2020/Figures/TagSeq/ModuleTraitClusterTree.pdf")
plot(moduleTraitTree)
dev.off()
```

Correlations of genes with eigengenes. Calculate correlations between ME's and lifestages. 
```{r}

moduleGeneCor=cor(MEs,datExpr)
moduleGenePvalue = corPvalueStudent(moduleGeneCor, nSamples);
```

Calculate kME values (module membership). 

```{r}
datKME = signedKME(datExpr, MEs, outputColumnName = "kME")
head(datKME)
```

Save module colors and labels for use in subsequent analyses.  

```{r}
save(MEs, moduleLabels, moduleColors, geneTree, file = "Mcap2020/Output/TagSeq/NetworkConstruction-stepByStep.RData") 

```

### Plot module-trait associations

Represent module trait correlations as a heatmap 
```{r}
textMatrix = paste(signif(moduleTraitCor, 2), "\n(",signif(moduleTraitPvalue, 1), ")", sep = "")
dim(textMatrix) = dim(moduleTraitCor)
head(textMatrix)

labeledHeatmap(Matrix = moduleTraitCor, xLabels = names(datTraits),  yLabels = names(MEs), ySymbols = names(MEs), cex.lab.y= 0.55, cex.lab.x= 0.55, colors = blueWhiteRed(50), textMatrix = textMatrix, setStdMargins = TRUE, cex.text = 0.25, textAdj = , zlim = c(-1,1), main = paste("Module-trait relationships"))

pdf(file="Mcap2020/Figures/TagSeq/Module-trait-relationships.pdf")
labeledHeatmap(Matrix = moduleTraitCor, xLabels = names(datTraits),  yLabels = names(MEs), ySymbols = names(MEs), cex.lab.y= 0.55, cex.lab.x= 0.55, colors = blueWhiteRed(50), textMatrix = textMatrix, setStdMargins = TRUE, cex.text = 0.25, textAdj = , zlim = c(-1,1), main = paste("Module-trait relationships"))
dev.off()
```

Generate a complex heatmap of module-trait relationships.  

```{r}
#bold sig p-values
#dendrogram with WGCNA MEtree cut-off
#colored y-axis

#Create list of pvalues for eigengene correlation with specific life stages
heatmappval <- signif(moduleTraitPvalue, 1)

#Make list of heatmap row colors
htmap.colors <- names(MEs)
htmap.colors <- gsub("ME", "", htmap.colors)

lifestage_order<-c("1_Egg", "2_Embryo", "3_Larvae1", "4_Larvae2", "5_Larvae3", "6_Larvae4", "7_Larvae6", "8_MetamorposedRecruit2", "9_CalcifyingRecruit1", "10_CalcifyingRecruit2")

library(dendsort)
row_dend = dendsort(hclust(dist(moduleTraitCor)))
col_dend = dendsort(hclust(dist(t(moduleTraitCor))))

pdf(file = "Mcap2020/Figures/TagSeq/Module-trait-relationship-heatmap.pdf", height = 8, width = 8)
ht=Heatmap(moduleTraitCor, name = "Eigengene", column_title = "Module-Lifestage Eigengene Correlation", 
        col = blueWhiteRed(50), 
        row_names_side = "left", 
        row_dend_side = "left",
        width = unit(5, "in"), 
        height = unit(4.5, "in"), 
        column_dend_reorder = TRUE, 
        #cluster_columns = hclust(dist(t(moduleTraitCor)), method = "average"),
        cluster_columns = col_dend,
        row_dend_reorder = TRUE,
        column_split = 6, 
        column_dend_height = unit(.5, "in"),
        #cluster_rows = METree, 
        cluster_rows = row_dend, 
        row_gap = unit(2.5, "mm"), 
        border = TRUE,
        cell_fun = function(j, i, x, y, w, h, col) {
        if(heatmappval[i, j] < 0.05) {
            grid.text(sprintf("%s", heatmappval[i, j]), x, y, gp = gpar(fontsize = 10, fontface = "bold"))
        }
        else {
            grid.text(sprintf("%s", heatmappval[i, j]), x, y, gp = gpar(fontsize = 10, fontface = "plain"))
        }},
        column_names_gp =  gpar(fontsize = 12, border=FALSE),
        row_names_gp = gpar(fontsize = 12, alpha = 0.75, border = FALSE))
draw(ht)
dev.off()

```







