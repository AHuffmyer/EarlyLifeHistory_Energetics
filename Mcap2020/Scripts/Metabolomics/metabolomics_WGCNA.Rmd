---
title: Montipora capitata 2020 metabolomics WGCNA analysis
author: "AS Huffmyer"
date: '2021'
output:
  html_document:
    code_folding: hide
    toc: yes
    toc_depth: 6
    toc_float: yes
  pdf_document:
    keep_tex: yes
editor_options: 
  chunk_output_type: console
---

Set up workspace, set options, and load required packages.    
```{r}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)

options(stringsAsFactors = FALSE) #Set Strings to character
```

```{r, warning=FALSE, message=FALSE}
## install packages if you dont already have them in your library
if ("tidyverse" %in% rownames(installed.packages()) == 'FALSE') install.packages('tidyverse') 
if ("vegan" %in% rownames(installed.packages()) == 'FALSE') install.packages('vegan') 
if ("ggplot2" %in% rownames(installed.packages()) == 'FALSE') install.packages('ggplot2') 
if ("factoextra" %in% rownames(installed.packages()) == 'FALSE') install.packages('factoextra') 
if ("ggfortify" %in% rownames(installed.packages()) == 'FALSE') install.packages('ggfortify') 
if ("naniar" %in% rownames(installed.packages()) == 'FALSE') install.packages('naniar') 
if ("cowplot" %in% rownames(installed.packages()) == 'FALSE') install.packages('cowplot') 
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
if ("mixOmics" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install("mixOmics") 
if ("RVAideMemoire" %in% rownames(installed.packages()) == 'FALSE') install.packages('RVAideMemoire') 
if ("VennDiagram" %in% rownames(installed.packages()) == 'FALSE') install.packages('VennDiagram') 
if ("broom" %in% rownames(installed.packages()) == 'FALSE') install.packages('broom') 
if ("devtools" %in% rownames(installed.packages()) == 'FALSE') install.packages('devtools') 

#load packages
library("ggplot2")
library('vegan')
library('factoextra')
library('ggfortify')
library('naniar')
library('cowplot')
library("mixOmics")
library("tidyverse")
library("RVAideMemoire")
library("VennDiagram")
library("broom")
library("devtools")

if ("genefilter" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install("genefilter") 
if ("DESeq2" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('DESeq2') 
if ("RColorBrewer" %in% rownames(installed.packages()) == 'FALSE') install.packages('RColorBrewer') 
if ("WGCNA" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('WGCNA') 
if ("flashClust" %in% rownames(installed.packages()) == 'FALSE') install.packages('flashClust') 
if ("gridExtra" %in% rownames(installed.packages()) == 'FALSE') install.packages('gridExtra') 
if ("ComplexHeatmap" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('ComplexHeatmap') 
if ("goseq" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('goseq') 
if ("dplyr" %in% rownames(installed.packages()) == 'FALSE') install.packages('dplyr') 
if ("clusterProfiler" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('clusterProfiler') 
if ("pheatmap" %in% rownames(installed.packages()) == 'FALSE') install.packages('pheatmap') 
if ("magrittr" %in% rownames(installed.packages()) == 'FALSE') install.packages('magrittr') 
if ("dendsort" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('dendsort') 
if ("MetaboAnalystR" %in% rownames(installed.packages()) == 'FALSE') devtools::install_github("xia-lab/MetaboAnalystR", build = TRUE, build_vignettes = FALSE) 

library("genefilter")
library("DESeq2")
library("RColorBrewer")
library("WGCNA")
library("flashClust")
library("gridExtra")
library("ComplexHeatmap")
library("goseq")
library("dplyr")
library("clusterProfiler")
library("pheatmap")
library("magrittr")
library("dendsort")
library("MetaboAnalystR")
```

This script uses WGCNA analysis on metabolomics data set to explore whether we can detect "modules" of genes that are correlated with lifestage. PLS-DA analyses and multivariate analyses are conducted in metabolomics.Rmd script. The pipeline in this script is modified from K. Wong script: 

# Pipeline Overview

1. Data preparation
  + Load and format clean data
  + Data filtering: PoverA and genefilter
  + Outlier detection
2. Network construction and consensus module detection
  + Choosing a soft-thresholding power: Analysis of a network topology β  
  + Identify modules using blockwiseModules  
  + Relate modules to sample information  
  + Relate modules to life stage
3. Plot module-trait associations
4. Plot mean eigengene values for each module  
5. Pathway analysis    

# 1. Data Preparation  

## Load and format clean data  

Read in data file and create metadata with sample information as well as a count matrix with metabolite counts. Data will be read in from "selected metabolites" dataset that has already undergone polarity selection, cleaning metabolite names, and median-centered normalized ion counts in the metabolomics.Rmd script.  

```{r}
data<-read.csv("Mcap2020/Output/Metabolomics/selected_metabolites.csv")

metadata<-data%>%
  select(Lifestage, Rep, HPF, Development)%>%
  mutate(Sample=paste(Lifestage, Rep, sep="-"))

metadata<-metadata[1:47,] #reduce to just one set of metadata 

data<-data%>%
  mutate(Sample=paste(Lifestage, Rep, sep="-"))%>%
  select(Sample, compound, norm_counts)
```

Convert the data table to a wide format with samples in columns and metabolites in rows.  

```{r}
data<-data%>%
  spread(Sample, norm_counts)

head(data)

rownames(data)<-data$compound

data<-data%>%
  select(-compound)
```

Check that there are no metabolites with 0 counts for all samples. Should return TRUE.  

```{r}
rowSums(dplyr::count(data)) > 0
```

## Data filtering: PoverA and genefilter  

Conduct data filtering, this includes:  

*pOverA*: Specifying the minimum count for a proportion of samples for each metabolite. Here, we are using a pOverA of 0.07. This is because we have 46 samples with a minimum of n=2 samples per lifestage. Therefore, we will accept genes that are present in 2/46 = 0.04 of the samples because we expect different metabolites by life stage as demonstrated by PLSDA analysis (as analyzed in metabolomics.Rmd). We are further setting the minimum value of metabolites to 1 (median normalized), such that 4% of the samples must have a non-zero normalized metabolite presence in order for the metabolite to remain in the data set.  

Filter in the package "genefilter". Pre-filtering our dataset to reduce the memory size dataframe, increase the speed of the transformation and testing functions, and improve quality of statistical analysis by removing low-coverage counts. Removed counts could represent outliers in the data and removing these improves sensitivity of statistical tests.   

```{r}
filt <- filterfun(pOverA(0.04,0.01))

#create filter for the counts data
gfilt <- genefilter(data, filt)

#identify genes to keep by count filter
keep <- data[gfilt,]

#identify gene lists
n.keep <- rownames(keep)

#gene count data filtered in PoverA, P percent of the samples have counts over A
data_filt <- as.data.frame(data[which(rownames(data) %in% n.keep),])

#How many rows do we have before and after filtering?
nrow(data) #Before
nrow(data_filt) #After
```

Filtering does not remove any metabolites, all 182 metabolites are used in analysis.  

Check that all row and column names match. Should return TRUE.  
```{r}
#Checking that all row and column names match. Should return "TRUE"
all(rownames(metadata$sample_id) %in% colnames(data_filt))
all(rownames(metadata$sample_id) == colnames(data_filt)) 
```

## Outlier detection  

Look for outliers by examining tree of metabolites  
```{r}
sampleTree = hclust(dist(data_filt), method = "average");
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
# The user should change the dimensions if the window is too large or too small.
pdf("Mcap2020/Figures/Metabolomics/WGCNA/outliers_metabolites.pdf")
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)
dev.off()
```

Betaine could be a large outlier, likely due to very high abundance compared to other metabolites. Try analysis with and without Betaine. Proceeding now without removing Betaine.    

```{r}
outlier<-c("Betaine")
#data_filt<-data_filt%>%
  #filter(!row.names(data_filt) %in% outlier)
```

Now look at the tree again.   
```{r}
sampleTree = hclust(dist(data_filt), method = "average");
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
# The user should change the dimensions if the window is too large or too small.
pdf("Mcap2020/Figures/Metabolomics/WGCNA/outliers_metabolites_filt.pdf")
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)
dev.off()
```

Transpose such that samples are in rows and metabolites are in columns.  

```{r}
data_filt <- t(data_filt) 
```

Look for outlier samples by examining tree of samples  
```{r}
sampleTree = hclust(dist(data_filt), method = "average");
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
# The user should change the dimensions if the window is too large or too small.
pdf("Mcap2020/Figures/Metabolomics/WGCNA/outliers_samples.pdf")
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)
dev.off()
```

No clear outliers.  


# 2. Network construction and consensus module detection  

## Choosing a soft-thresholding power: Analysis of network topology β  

The soft thresholding power (β) is the number to which the co-expression similarity is raised to calculate adjacency. The function pickSoftThreshold performs a network topology analysis. The user chooses a set of candidate powers, however the default parameters are suitable values.  
```{r, message=FALSE, warning=FALSE}
# # Choose a set of soft-thresholding powers
allowWGCNAThreads()

powers <- c(c(1:20), seq(from = 12, to=20, by=2)) #Create a string of numbers from 1 through 10, and even numbers from 10 through 20
# 
# # Call the network topology analysis function
sft <-pickSoftThreshold(data_filt, powerVector = powers, verbose = 5)
```

Plot the results.  
```{r}
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# # # Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
      xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
 text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# # # this line corresponds to using an R^2 cut-off
 abline(h=0.8,col="red")
# # # Mean connectivity as a function of the soft-thresholding power
 plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
 text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
```

From this data, it appears that our **soft thresholding power is 7**.  

## Identify modules using blockwiseModules  

Use blockwiseModules to identify modules of metabolites.  

Settings used: 

networkType = "unsigned" 
deepSplit = 2
pamRespectsDendro = F
minModuleSize = 5
maxBlockSize = 4000
reassignThreshold = 0
mergeCutHeight = 0.25

Need to change RData output 

``` {r, echo=TRUE, warning=FALSE, message=FALSE}

picked_power = 7
temp_cor <- cor       
cor <- WGCNA::cor                                             # Force it to use WGCNA cor function (fix a namespace conflict issue)
netwk <- blockwiseModules(data_filt,                         # <= input here

                          # == Adjacency Function ==
                          power = picked_power,               # <= power here
                          networkType = "unsigned",

                          # == Tree and Block Options ==
                          deepSplit = 2,
                          pamRespectsDendro = F,
                          # detectCutHeight = 0.75,
                          minModuleSize = 5,                  #consider increasing or decreasing this
                          maxBlockSize = 4000,

                          # == Module Adjustments ==
                          reassignThreshold = 0,
                          mergeCutHeight = 0.25,

                          # == TOM == Archive the run results in TOM file (saves time) but it doesn't save a file
                          saveTOMs = F,
                          saveTOMFileBase = "ER",

                          # == Output Options
                          numericLabels = T,
                          verbose = 3)

cor <- temp_cor     # Return cor function to original namespace

# Identify labels as numbers 
mergedColors = netwk$colors
# Plot the dendrogram and the module colors underneath

pdf("Mcap2020/Figures/Metabolomics/WGCNA/blockwise_module_colors.pdf")
plotDendroAndColors(
  netwk$dendrograms[[1]],
  mergedColors[netwk$blockGenes[[1]]],
  "Module colors",
  dendroLabels = FALSE,
  hang = 0.03,
  addGuide = TRUE,
  guideHang = 0.05 )
dev.off()
```

## Relate modules to sample information  

``` {r, echo=TRUE, warning=FALSE, message=FALSE}
module_df <- data.frame(
  Metabolite = names(netwk$colors),
  colors = netwk$colors
  #colors = labels2colors(netwk$colors)
)

module_df[1:5,]

write.csv(module_df, "Mcap2020/Output/Metabolomics/WGCNA/metabolite_modules.csv")

# Get Module Eigengenes per cluster
MEs <- moduleEigengenes(data_filt, mergedColors)$eigengenes

# Reorder modules so similar modules are next to each other
MEs <- orderMEs(MEs)
module_order = names(MEs) %>% gsub("ME","", .)

# Add Sample names
MEs0 <- MEs
MEs0$Sample.ID = row.names(MEs)

# tidy & plot data
mME = MEs0 %>%
  pivot_longer(-Sample.ID) %>%
  mutate(
    name = gsub("ME", "", name),
    name = factor(name, levels = module_order)
  )

mME %>% ggplot(., aes(x=Sample.ID, y=name, fill=value)) +
  geom_tile() +
  theme_bw() +
  scale_fill_gradient2(
    low = "blue",
    high = "red",
    mid = "white",
    midpoint = 0,
    limit = c(-1,1)) +
  theme(axis.text.x = element_text(angle=90)) +
  labs(title = "Module-Sample Relationships", y = "Modules", fill="corr")
```


## Relate modules to life stage  

Prepare trait data. Data has to be numeric, so I will substitute time points/developmental stages for numeric values. The "trait" we are considering here is lifestage. Make a dataframe that has a column for each lifestage name and a row for samples. Populate a 1 for samples that match each lifestage and a 0 for samples not matching respective lifestages. This process changes lifestages from a categorical variable into a binary variable. This will allow for correlations between mean eigengenes and lifestage.  
 
```{r}
metadata$num <- c("1")
allTraits <- as.data.frame(pivot_wider(metadata, names_from = Lifestage, values_from = num, id_cols = Sample))
allTraits[is.na(allTraits)] <- c("0")
rownames(allTraits) <- allTraits$Sample
datTraits <- allTraits[,c(-1)]
head(datTraits)

#define numbers of metabolites and samples and view 
nMetabolites = ncol(data_filt)
nSamples = nrow(data_filt)

nMetabolites
nSamples
```

We have 182 metabolites and 47 samples.   

Next correlate the trait of life stage with eigengenes (modules).  

```{r}
# Correlations of traits with eigengenes
moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);
Colors=sub("ME","", names(MEs))
moduleTraitTree = hclust(dist(t(moduleTraitCor)), method = "average")
pdf(file="Mcap2020/Figures/Metabolomics/WGCNA/ModuleTraitClusterTree.pdf", height=8, width=22)
plot(moduleTraitTree)
dev.off()

# Correlations of metabolites with eigengenes. Calculate correlations between ME's and groups 
moduleGeneCor=cor(MEs,data_filt)
moduleGenePvalue = corPvalueStudent(moduleGeneCor, nSamples);
head(moduleGenePvalue)
```

## Plot module-trait associations

Represent module trait correlations as a heatmap.  
```{r, echo=TRUE, warning=FALSE, message=FALSE}
textMatrix = paste(signif(moduleTraitCor, 2), "\n(",signif(moduleTraitPvalue, 1), ")", sep = "")
dim(textMatrix) = dim(moduleTraitCor)
head(textMatrix)
labeledHeatmap(Matrix = moduleTraitCor, xLabels = names(datTraits),  yLabels = names(MEs), ySymbols = names(MEs), cex.lab.y= 0.55, cex.lab.x= 0.55, colors = blueWhiteRed(50), textMatrix = textMatrix, setStdMargins = TRUE, cex.text = 0.25, textAdj = , zlim = c(-1,1), main = paste("Module-trait relationships"))
pdf(file="Mcap2020/Figures/Metabolomics/WGCNA/Module-trait-relationships.pdf")
labeledHeatmap(Matrix = moduleTraitCor, xLabels = names(datTraits),  yLabels = names(MEs), ySymbols = names(MEs), cex.lab.y= 0.55, cex.lab.x= 0.55, colors = blueWhiteRed(50), textMatrix = textMatrix, setStdMargins = TRUE, cex.text = 0.25, textAdj = , zlim = c(-1,1), main = paste("Module-trait relationships"))
dev.off()

```

# 3. Plot module triat associations with a complex heatmap   

```{r, echo=TRUE, warning=FALSE, message=FALSE}
#bold sig p-values
#dendrogram with WGCNA MEtree cut-off
#colored y-axis
#Create list of pvalues for eigengene correlation with specific life stages
heatmappval <- signif(moduleTraitPvalue, 1)
#Make list of heatmap row colors
htmap.colors <- names(MEs)
htmap.colors <- gsub("ME", "", htmap.colors)

row_dend = dendsort(hclust(dist(moduleTraitCor)))
col_dend = dendsort(hclust(dist(t(moduleTraitCor))))


#row_ha = rowAnnotation(ModuleSize = anno_text("11", "127", "8", "64", "85"), just = "left", 
#        location = unit(0.5, "npc"), show_name = TRUE)
# brown (11), grey (127), yellow (8), blue (64), turqoise (85) #figure out how to do row annotations to add sample sizes

pdf(file = "Mcap2020/Figures/Metabolomics/WGCNA/Module-trait-relationship-heatmap.pdf", height = 8, width = 8)
ht=Heatmap(moduleTraitCor, name = "Eigengene", column_title = "Module-Group Eigengene Correlation", 
        col = blueWhiteRed(50), 
        row_names_side = "left", 
        row_dend_side = "left",
        width = unit(5, "in"), 
        height = unit(4.5, "in"), 
        column_dend_reorder = TRUE, 
        cluster_columns = col_dend,
        row_dend_reorder = FALSE,
        column_split = 4, 
        row_split = 3, 
        column_dend_height = unit(.5, "in"),
        cluster_rows = row_dend, 
        row_gap = unit(2.5, "mm"), 
        border = TRUE,
        cell_fun = function(j, i, x, y, w, h, col) {
        if(heatmappval[i, j] < 0.05) {
            grid.text(sprintf("%s", heatmappval[i, j]), x, y, gp = gpar(fontsize = 10, fontface = "bold"))
        }
        else {
            grid.text(sprintf("%s", heatmappval[i, j]), x, y, gp = gpar(fontsize = 10, fontface = "plain"))
        }},
        column_names_gp =  gpar(fontsize = 12, border=FALSE),
        row_names_gp = gpar(fontsize = 12, alpha = 0.75, border = FALSE))
draw(ht)
dev.off()
```


# 4. Plot mean eigengene values for each module

Load metadata and plot expression plots.  
```{r, echo=TRUE, warning=FALSE, message=FALSE}

# Number of each metabolites in each module 
row_mod_num <- data.frame(table(module_df$colors)) 

# Bring in additional metadata

sample_metadata <- read.csv("Mcap2020/Data/Metabolomics/metabolomics_meta_wgcna.csv") 

sample_metadata$Sample.ID <- as.factor(sample_metadata$Sample.ID)
sample_metadata$lifestage <- as.factor(sample_metadata$lifestage)
sample_metadata$hpf <- as.factor(sample_metadata$hpf)
sample_metadata$group <- as.factor(sample_metadata$group)

mME_meta <- merge(mME, sample_metadata, by = "Sample.ID") %>%
  rename(Module = name)
```

Add module "cluster" categories determined by WGCNA above.  
```{r}
mME_meta<-mME_meta%>%
  mutate(Cluster=if_else(Module == "2", "Cluster1", 
                               if_else(Module =="5", "Cluster1", 
                                       if_else(Module == "0", "Cluster1", 
                                               if_else(Module == "7", "Cluster2",
                                               if_else(Module=="6", "Cluster2", 
                                                       if_else(Module == "3", "Cluster2", 
                                                       if_else(Module == "1", "Cluster3", 
                                                               if_else(Module == "8", "Cluster3",
                                                               if_else(Module == "4", "Cluster3", "NA"))))))))))

mME_meta$Cluster<-as.factor(mME_meta$Cluster)
```


Plot by time point with individual modules.  
```{r}

mME_meta$group <- factor(mME_meta$group, levels = c("Egg", "Embryo", "Larvae", "Metamorphosed Recruit", "Attached Recruit"))
mME_meta$Module <- factor(mME_meta$Module, levels = c("0", "1", "2", "3", "4", "5", "6", "7", "8"))

expression_plots<-mME_meta%>%
#  group_by(Module) %>%
  ggplot(aes(x=hpf, y=value, fill=group)) +
  facet_wrap(~ Module)+
  ylab("Mean Module Eigenegene Value") +
  geom_hline(yintercept = 0, linetype="dashed", color = "grey")+
  geom_boxplot(width=.5, outlier.shape= NA, position = position_dodge(width = 0.5), alpha = 0.7) +
  stat_summary(fun=mean, geom="line", aes(group=lifestage, color = group), position = position_dodge(width = 0.5))  + 
  geom_point(pch = 21, position = position_dodge(width = 0.5)) +
  scale_fill_manual(name="Lifestage", values=c("#8C510A", "#DFC27D","#80CDC1", "#003C30", "#BA55D3")) +
  scale_color_manual(name="Lifestage", values=c("#8C510A", "#DFC27D","#80CDC1", "#003C30", "#BA55D3")) + 
  xlab("Hours Post-Fertilization") + #Axis titles
  theme_bw() + theme(panel.border = element_rect(color="black", fill=NA, size=0.75), panel.grid.major = element_blank(), #Makes background theme white
                     panel.grid.minor = element_blank(), axis.line = element_blank()) +
  theme(axis.text = element_text(size = 11 , color = "black"),
        axis.title = element_text(size = 16, color = "black"), 
        axis.text.x = element_text(size=11, color="black"), 
        legend.title=element_blank(), 
        legend.text=element_text(color="black", size=12)); expression_plots

ggsave(filename="Mcap2020/Figures//Metabolomics/WGCNA/expression_eigengene.jpeg", plot=expression_plots, dpi=300, width=12, height=8, units="in")

```

Plot by time point with module clusters.  
```{r}
mME_meta$group <- factor(mME_meta$group, levels = c("Egg", "Embryo", "Larvae", "Metamorphosed Recruit", "Attached Recruit"))
mME_meta$Cluster <- factor(mME_meta$Cluster, levels = c("Cluster1", "Cluster2", "Cluster3"))

expression_plots_cluster<-mME_meta%>%
#  group_by(Module) %>%
  ggplot(aes(x=hpf, y=value, fill=group)) +
  facet_grid(Cluster ~.)+
  ylab("Mean Module Cluster Eigenegene Value") +
  geom_hline(yintercept = 0, linetype="dashed", color = "grey")+
  geom_boxplot(width=.5, outlier.shape= NA, position = position_dodge(width = 0.5), alpha = 0.7) +
  stat_summary(fun=mean, geom="line", aes(group=lifestage, color = group), position = position_dodge(width = 0.5))  + 
  geom_point(pch = 21, position = position_dodge(width = 0.5)) +
  scale_fill_manual(name="Lifestage", values=c("#8C510A", "#DFC27D","#80CDC1", "#003C30", "#BA55D3")) +
  scale_color_manual(name="Lifestage", values=c("#8C510A", "#DFC27D","#80CDC1", "#003C30", "#BA55D3")) + 
  xlab("Hours Post-Fertilization") + #Axis titles
  theme_bw() + theme(panel.border = element_rect(color="black", fill=NA, size=0.75), panel.grid.major = element_blank(), #Makes background theme white
                     panel.grid.minor = element_blank(), axis.line = element_blank()) +
  theme(axis.text = element_text(size = 11 , color = "black"),
        axis.title = element_text(size = 16, color = "black"), 
        axis.text.x = element_text(size=11, color="black"), 
        legend.position="top", 
        legend.title=element_blank(), 
        legend.text=element_text(color="black", size=12), 
        strip.text.y = element_text(size = 14, color = "black", face = "bold.italic")); expression_plots_cluster

ggsave(filename="Mcap2020/Figures//Metabolomics/WGCNA/expression_eigengene_cluster.jpeg", plot=expression_plots_cluster, dpi=300, width=7, height=10, units="in")

``` 


# 5. Pathway Analysis  

Conduct pathway analysis for each module cluster - clusters 1, 2, and 3 as determined by WGCNA analysis above.  

First, generate a list of metabolites contained within each module cluster.  

```{r, echo=TRUE, warning=FALSE, message=FALSE}

module_df <- read.csv("Mcap2020/Output/Metabolomics/WGCNA/metabolite_modules.csv")

module_df <- module_df %>% rename(Module = colors)

# Select metabolites for each module 
cluster1<-c("2", "5", "0")
cluster2<-c("7", "6", "3")
cluster3<-c("1", "8", "4")

module_cluster1 <- module_df %>% filter(Module %in% cluster1)  %>% select(Metabolite)
module_cluster2 <- module_df %>% filter(Module %in% cluster2)  %>% select(Metabolite)
module_cluster3 <- module_df %>% filter(Module %in% cluster3)  %>% select(Metabolite)
```

Cluster 1 = 53 metabolites
Cluster 2 = 41 metabolites
Cluster 3 = 88 metabolites 

R script currently not working, conducting analysis in MetaboAnalyst interface.  

*Note that Montiporic Acid A, B, C, and D are present in module clusters 2 but are not able to be used in the analysis since they are not in the reference database.*  

## 1. Enrichment analysis 

https://www.metaboanalyst.ca/MetaboAnalyst/upload/EnrichUploadView.xhtml

Enrichment analysis - Main class chemical structures

Loaded list of each module metabolites and corrected names to match in database. Output .csv to Output/Metabolmoics/Metaboanalyst

## 2. Pathway analysis 

https://www.metaboanalyst.ca/MetaboAnalyst/upload/EnrichUploadView.xhtml

Enrichment analysis - KEGG Pathway based analysis 

Loaded list of each module metabolites and corrected names to match in database. Output .csv to Output/Metabolmoics/Metaboanalyst

## 3. View results  

From these lists, we can identify the pathways that are significantly enriched. 

### KEGG Pathways  

Load data output from Metaboanalyst and join into a single dataframe.    

```{r}
cluster1_kegg<-read.csv("Mcap2020/Output/Metabolomics/Metaboanalyst/Cluster1_KEGG.csv")
cluster1_kegg$Cluster<-"Cluster1"

cluster2_kegg<-read.csv("Mcap2020/Output/Metabolomics/Metaboanalyst/Cluster2_KEGG.csv")
cluster2_kegg$Cluster<-"Cluster2"

cluster3_kegg<-read.csv("Mcap2020/Output/Metabolomics/Metaboanalyst/Cluster3_KEGG.csv")
cluster3_kegg$Cluster<-"Cluster3"

kegg_pathways<-rbind(cluster1_kegg, cluster2_kegg, cluster3_kegg)
```

Filter out pathways that are significantly enriched with FDR p value <0.05.  

```{r}
sig_pathways<-kegg_pathways%>%
  filter(FDR<0.05)%>%
  select(pathway, hits, FDR, Cluster)%>%
  write.csv("Mcap2020/Output/Metabolomics/Metaboanalyst/KEGG_sign_pathways.csv")
```

### Compound Classes   

Load data output from Metaboanalyst and join into a single dataframe.    

```{r}
cluster1_class<-read.csv("Mcap2020/Output/Metabolomics/Metaboanalyst/Cluster1_Enrichment.csv")
cluster1_class$Cluster<-"Cluster1"

cluster2_class<-read.csv("Mcap2020/Output/Metabolomics/Metaboanalyst/Cluster2_Enrichment.csv")
cluster2_class$Cluster<-"Cluster2"

cluster3_class<-read.csv("Mcap2020/Output/Metabolomics/Metaboanalyst/Cluster3_Enrichment.csv")
cluster3_class$Cluster<-"Cluster3"

compound_classes<-rbind(cluster1_class, cluster2_class, cluster3_class)
```

Filter out pathways that are significantly enriched with FDR p value <0.05.  

```{r}
sig_classes<-compound_classes%>%
  filter(FDR<0.05)%>%
  select(class, hits, FDR, Cluster)%>%
  write.csv("Mcap2020/Output/Metabolomics/Metaboanalyst/compound_sign_classes.csv")
```

