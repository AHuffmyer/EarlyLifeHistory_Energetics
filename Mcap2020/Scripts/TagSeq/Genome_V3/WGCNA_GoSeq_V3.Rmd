---
title: "WGCNA - GoSeq Functional Annotation"
author: "Ariana S Huffmyer"
date: "2022"
output: html_document
editor_options: 
  chunk_output_type: console
---

Functional enrichment of WGCNA modules produced in `WGCNA_Mcap.Rmd` script for the *Montipora capitata* 2020 developmental time series.  This script uses the V3 genome from Cyanophora Rutgers.  

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)

# The following setting is important, do not omit.
options(stringsAsFactors = FALSE) #Set Strings to character
```

Load required libraries.  

```{r}
if ("tidyverse" %in% rownames(installed.packages()) == 'FALSE') install.packages('tidyverse') 
if ("genefilter" %in% rownames(installed.packages()) == 'FALSE') install.packages('genefilter') 
if ("DESeq2" %in% rownames(installed.packages()) == 'FALSE') install.packages('DESeq2') 
if ("RColorBrewer" %in% rownames(installed.packages()) == 'FALSE') install.packages('RColorBrewer') 
if ("WGCNA" %in% rownames(installed.packages()) == 'FALSE') install.packages('WGCNA') 
if ("flashClust" %in% rownames(installed.packages()) == 'FALSE') install.packages('flashClust') 
if ("gridExtra" %in% rownames(installed.packages()) == 'FALSE') install.packages('gridExtra') 
if ("ComplexHeatmap" %in% rownames(installed.packages()) == 'FALSE') install.packages('ComplexHeatmap') 
if ("goseq" %in% rownames(installed.packages()) == 'FALSE') install.packages('goseq') 
if ("dplyr" %in% rownames(installed.packages()) == 'FALSE') install.packages('dplyr') 
if ("clusterProfiler" %in% rownames(installed.packages()) == 'FALSE') install.packages('clusterProfiler') 
if ("pheatmap" %in% rownames(installed.packages()) == 'FALSE') install.packages('pheatmap') 
if ("magrittr" %in% rownames(installed.packages()) == 'FALSE') install.packages('magrittr') 
if ("rtracklayer" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install("rtracklayer")
if ("GenomicRanges" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install("GenomicRanges")
if ("plyranges" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install("plyranges")
if ("GSEABase" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install("GSEABase")
if ("GOSim" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install("GOSim")
if ("stats" %in% rownames(installed.packages()) == 'FALSE') install.packages("stats")
if ("ggdendro" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install("ggdendro")

library("tidyverse")
library("genefilter")
library("DESeq2")
library("RColorBrewer")
library("WGCNA")
library("flashClust")
library("gridExtra")
library("ComplexHeatmap")
library("goseq")
library("dplyr")
library("clusterProfiler")
library("pheatmap")
library("magrittr")
library("rtracklayer")
library("GenomicRanges")
library("plyranges")
library("GSEABase")
library("GOSim")
library("stats")
library("ggdendro")
```

# **Read in data**  

Load in Gene Info data frame generated in WGCNA_Mcap.Rmd script and subset list of genes and module assignment for each gene.   

```{r}
geneInfo<-read.csv("Mcap2020/Output/TagSeq/GenomeV3/geneInfo.csv")
dim(geneInfo)

geneInfo<-geneInfo%>%
  #dplyr::select(gene_id, moduleColor)%>%
  rename(Module=moduleColor)%>%
  mutate(Module=as.factor(Module))

dim(geneInfo)
```

There are 14595 genes in our Gene Info file.  

Get gene length information.  
```{r}
#import file
gff <- import("Mcap2020/Data/TagSeq/Montipora_capitata_HIv3.genes.gff3")

transcripts <- subset(gff, type == "transcript") #keep only transcripts 

transcripts_gr <- makeGRangesFromDataFrame(transcripts, keep.extra.columns=TRUE) #extract length information

transcript_lengths <- width(transcripts_gr) #isolate length of each gene

seqnames<-transcripts_gr$ID #extract list of gene id 

lengths<-cbind(seqnames, transcript_lengths)

lengths<-as.data.frame(lengths) #convert to data frame

```

Add in length to the gene info file .    

```{r}
geneInfo$Length<-lengths$transcript_lengths[match(geneInfo$gene_id, lengths$seqnames)]
```

Format GO terms to remove dashes and quotes.  
```{r}
#remove dashes, remove quotes from columns and separate by semicolons (replace , with ;) in KEGG_ko, KEGG_pathway, and Annotation.GO.ID columns
geneInfo$Annotation.GO.ID <- gsub(",", ";", geneInfo$Annotation.GO.ID)
geneInfo$Annotation.GO.ID <- gsub('"', "", geneInfo$Annotation.GO.ID)
geneInfo$Annotation.GO.ID <- gsub("-", NA, geneInfo$Annotation.GO.ID)

geneInfo$KEGG_ko <- gsub(",", ";", geneInfo$KEGG_ko)
geneInfo$KEGG_ko <- gsub('"', "", geneInfo$KEGG_ko)
geneInfo$KEGG_ko <- gsub("-", NA, geneInfo$KEGG_ko)

geneInfo$KEGG_pathway <- gsub(",", ";", geneInfo$KEGG_pathway)
geneInfo$KEGG_pathway <- gsub('"', "", geneInfo$KEGG_pathway)
geneInfo$KEGG_pathway <- gsub("-", NA, geneInfo$KEGG_pathway)
```

# **Download and merge in GoSlim terms**  

Create a slim key by pulling out all GO terms in our list of genes.    

```{r}
go_list <- geneInfo %>% 
  dplyr::select(Annotation.GO.ID)%>%
  filter(complete.cases(Annotation.GO.ID))

#split each row into a separate row for each go term 
split <- strsplit(as.character(go_list$Annotation.GO.ID), ";") 
split2 <- data.frame(v1 = unlist(split)) 
colnames(split2) <- c("GO.Term")

go_list<-split2
```

Set name of output file
```{r}
### Set output filename suffix
output_suffix=("GOslims.csv")
```

Make a vector of GOslim ontologies (e.g. Biological Process = BP, Molecular Function = MF, Cellular Component = CC)
```{r}
ontologies <- c("BP", "CC", "MF")
```

Determine GOslims. Script courtesy of Sam White in the UW Roberts Lab. 
```{r determine-goslims}
for (slim_ontology in ontologies) {
  
    ### Set GOOFFSPRING database, based on ontology group set above
    go_offspring <- paste("GO", slim_ontology, "OFFSPRING", sep = "")
    
    ## Grab just the individual GO terms from the "GO.Term" column)
    goterms <- as.character(go_list$GO.Term)
    
    ### Use GSEA to map GO terms to GOslims
    
    ## Store goterms as GSEA object
    myCollection <- GOCollection(goterms)
    
    ## Use generic GOslim file to create a GOslim collection
    
    # I downloaded goslim_generic.obo from http://geneontology.org/docs/go-subset-guide/
    uri <- "http://current.geneontology.org/ontology/subsets/goslim_pir.obo"
    slim <- getOBOCollection(uri)
    
    ## Map GO terms to GOslims and select ontology group
    slimsdf <- goSlim(myCollection, slim, slim_ontology)
    
    ## Need to know the 'offspring' of each term in the ontology, and this is given by the data in:
    # GO.db::getFromNamespace(go_offspring, "GO.db")
    
    ## Create function to parse out GO terms assigned to each GOslim
    ## Courtesy Bioconductor Support: https://support.bioconductor.org/p/128407/
    mappedIds <-
      function(df, collection, OFFSPRING)
      {
        map <- as.list(OFFSPRING[rownames(df)])
        mapped <- lapply(map, intersect, ids(collection))
        df[["go_terms"]] <- vapply(unname(mapped), paste, collapse = ";", character(1L))
        df
      }
    
    ## Run the function
    slimsdf <- mappedIds(slimsdf, myCollection, getFromNamespace(go_offspring, "GO.db"))
    
    ## Provide column name for first column
    slimsdf <- cbind(GOslim = rownames(slimsdf), slimsdf)
    rownames(slimsdf) <- NULL
    
    ## Paste elements together to form output filename
    outfilename <- paste("goslims", slim_ontology, output_suffix, collapse = ".", sep = ".")
    
    ## Set output file destination and name
    ## Adds proper subdirectory from split_dirs list
    outfile_dest <- file.path("Mcap2020/Output/TagSeq/GenomeV3", outfilename)
    
    ## Write output file
    write.csv(slimsdf, file = outfile_dest, quote = FALSE, row.names = FALSE)
    }
```

The output files now have GO Terms mapped to each GOSlim term.  

Now import the files and make a data frame that can be read to match GO terms to. 

```{r}
slimMF<-read_csv("Mcap2020/Output/TagSeq/GenomeV3/goslims.MF.GOslims.csv", na=c("NA"))
slimBP<-read_csv("Mcap2020/Output/TagSeq/GenomeV3/goslims.BP.GOslims.csv", na=c("NA"))
slimCC<-read_csv("Mcap2020/Output/TagSeq/GenomeV3/goslims.CC.GOslims.csv", na=c("NA"))
```

```{r}
slimMF$ontology<-"MF"
slimBP$ontology<-"BP"
slimCC$ontology<-"CC"

#join all together
go_slim_cats<-rbind(slimMF, slimBP, slimCC)

#make single go term for each row with repeating go slim 
split <- strsplit(as.character(go_slim_cats$go_terms), ";") 

split2 <- data.frame(GOslim = rep.int(go_slim_cats$GOslim, sapply(split, length)), GOterm = unlist(split), SlimTerm = rep.int(go_slim_cats$Term, sapply(split, length)), ontology = rep.int(go_slim_cats$ontology, sapply(split, length))) 

go_slim<-split2

```

# **Run GoSeq by Module**  

## 1. Generate a list of module numbers that we want to run in a loop through the GOSeq function.  
```{r}
module_vector<-c(levels(geneInfo$Module))
```

## 2. Run the GOSeq function in a loop by module number to test for GO term enrichment .  
```{r}
for (module in module_vector) {
  
    ### Generate vector with names of all genes 
    ALL.vector <- c(geneInfo$gene_id)
    
    ### Generate length vector for all genes 
    LENGTH.vector <- as.integer(geneInfo$Length)
    
    ### Generate vector with names in just the module we are analyzing
    ID.vector <- geneInfo%>%
      filter(Module==module)%>%
      #get_rows(.data[[module]]))%>%
      pull(gene_id)
    
    ##Get a list of GO Terms for each module
    GO.terms <- geneInfo%>%
      filter(Module==module)%>%
      #filter(get_rows(.data[[module]]))%>%
      dplyr::select(gene_id, Annotation.GO.ID)
    
    ##Format to have one goterm per row with gene ID repeated
    split <- strsplit(as.character(GO.terms$Annotation.GO.ID), ";") 
    split2 <- data.frame(v1 = rep.int(GO.terms$gene, sapply(split, length)), v2 = unlist(split)) 
    colnames(split2) <- c("gene", "Annotation.GO.ID")
    GO.terms<-split2

    ##Construct list of genes with 1 for genes in module and 0 for genes not in the module
    gene.vector=as.integer(ALL.vector %in% ID.vector) 
    names(gene.vector)<-ALL.vector#set names

    #weight gene vector by bias for length of gene 
    pwf<-nullp(gene.vector, ID.vector, bias.data=LENGTH.vector) 
    
    #run goseq using Wallenius method for all categories of GO terms 
    GO.wall<-goseq(pwf, ID.vector, gene2cat=GO.terms, test.cats=c("GO:BP", "GO:MF", "GO:CC"), method="Wallenius", use_genes_without_cat=TRUE)

    GO <- GO.wall[order(GO.wall$over_represented_pvalue),]
    colnames(GO)[1] <- "GOterm"
  
    #Filtering for p > 0.05
    GO <- GO %>%
        dplyr::filter(over_represented_pvalue<0.05) %>%
        dplyr::arrange(., ontology, over_represented_pvalue)

    #Write file of results 
    write_csv(GO, file = paste0("Mcap2020/Output/TagSeq/GenomeV3/GOSeq/goseq_module", module, ".csv"))
    
}
```

Run a loop to plot enrichment for each module at each level of ontology.  
```{r}
module_vector<-c(levels(geneInfo$Module))
ontologies<-c("BP", "MF", "CC")

for (module in module_vector) {
  
  for (category in ontologies) {

    #Read relevant file of results from goseq analysis  
    go_results<-read_csv(file = paste0("Mcap2020/Output/TagSeq/GenomeV3/GOSeq/goseq_module", module, ".csv"))
    
    go_results<-go_results%>%
      filter(ontology==category)%>%
      filter(over_represented_pvalue != "NA") %>%
      filter(numInCat >5)%>%
      arrange(., over_represented_pvalue)
    
    #plot significantly enriched GO terms by Slim Category
  GO.plot <-  ggplot(go_results, aes(x = ontology, y = term)) + 
    geom_point(aes(fill=over_represented_pvalue)) + 
    theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
    panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"),
    strip.text.y = element_text(angle=0, size = 10),
    strip.text.x = element_text(size = 20),
    axis.text = element_text(size = 8),
    axis.title.x = element_blank(),
    axis.title.y = element_blank())

ggsave(filename=paste0("Mcap2020/Figures/TagSeq/GenomeV3/GOSeq/GOenrich_Module", module, "_", category, ".png"), plot=GO.plot, dpi=300, width=12, height=12, units="in")
    
  }
}

```







Questions for Jill: 
- Why so many terms enriched? What to do with all of them? 
- Functional annotation of this genome? 
- How to map to goslim - are multiple go slim possible for single GO term?
- How to do semantic similarity? 


Need to repeat for KEGG terms 
Map to Goslim? 




Run a loop to calculate semantic similarity between GOTerms for each ontology for each module and plot results.  

THIS ISN'T USEFUL RIGHT NOW, TOO MANY TERMS 
```{r}
module_vector<-c("1")
ontologies<-c("CC")

for (module in module_vector) {
  
  for (category in ontologies) {

    #Read relevant file of results from goseq analysis  
    go_results<-read_csv(file = paste0("Mcap2020/Output/TagSeq/GenomeV3/GOSeq/goseq_module", module, ".csv"))
    
    go_results<-go_results%>%
      filter(ontology==category)
    
    #Calculate semantic similarity between GOTerms for each module 
    sem_sim<-getTermSim(go_results$GOterm, method = "relevance", verbose = FALSE)
    
    #Calculate distance matrix 
    hc <- hclust(as.dist(1 - sem_sim))
    
    ggdendrogram(hc)
  }
}
```







