---
title: Montipora capitata 2020 metabolomics WGCNA analysis
author: "AS Huffmyer"
date: '2021'
output:
  html_document:
    code_folding: hide
    toc: yes
    toc_depth: 6
    toc_float: yes
  pdf_document:
    keep_tex: yes
editor_options: 
  chunk_output_type: console
---

Set up workspace, set options, and load required packages.    
```{r}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)

options(stringsAsFactors = FALSE) #Set Strings to character
```

```{r, warning=FALSE, message=FALSE}
## install packages if you dont already have them in your library
if ("tidyverse" %in% rownames(installed.packages()) == 'FALSE') install.packages('tidyverse') 
if ("vegan" %in% rownames(installed.packages()) == 'FALSE') install.packages('vegan') 
if ("ggplot2" %in% rownames(installed.packages()) == 'FALSE') install.packages('ggplot2') 
if ("factoextra" %in% rownames(installed.packages()) == 'FALSE') install.packages('factoextra') 
if ("ggfortify" %in% rownames(installed.packages()) == 'FALSE') install.packages('ggfortify') 
if ("naniar" %in% rownames(installed.packages()) == 'FALSE') install.packages('naniar') 
if ("cowplot" %in% rownames(installed.packages()) == 'FALSE') install.packages('cowplot') 
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
if ("mixOmics" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install("mixOmics") 
if ("RVAideMemoire" %in% rownames(installed.packages()) == 'FALSE') install.packages('RVAideMemoire') 
if ("VennDiagram" %in% rownames(installed.packages()) == 'FALSE') install.packages('VennDiagram') 
if ("broom" %in% rownames(installed.packages()) == 'FALSE') install.packages('broom') 
if ("devtools" %in% rownames(installed.packages()) == 'FALSE') install.packages('devtools') 

#load packages
library("ggplot2")
library('vegan')
library('factoextra')
library('ggfortify')
library('naniar')
library('cowplot')
library("mixOmics")
library("tidyverse")
library("RVAideMemoire")
library("VennDiagram")
library("broom")
library("devtools")

if ("genefilter" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install("genefilter") 
if ("DESeq2" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('DESeq2') 
if ("RColorBrewer" %in% rownames(installed.packages()) == 'FALSE') install.packages('RColorBrewer') 
if ("WGCNA" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('WGCNA') 
if ("flashClust" %in% rownames(installed.packages()) == 'FALSE') install.packages('flashClust') 
if ("gridExtra" %in% rownames(installed.packages()) == 'FALSE') install.packages('gridExtra') 
if ("ComplexHeatmap" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('ComplexHeatmap') 
if ("goseq" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('goseq') 
if ("dplyr" %in% rownames(installed.packages()) == 'FALSE') install.packages('dplyr') 
if ("clusterProfiler" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('clusterProfiler') 
if ("pheatmap" %in% rownames(installed.packages()) == 'FALSE') install.packages('pheatmap') 
if ("magrittr" %in% rownames(installed.packages()) == 'FALSE') install.packages('magrittr') 
if ("dendsort" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('dendsort') 
if ("MetaboAnalystR" %in% rownames(installed.packages()) == 'FALSE') devtools::install_github("xia-lab/MetaboAnalystR", build = TRUE, build_vignettes = FALSE) 

library("genefilter")
library("DESeq2")
library("RColorBrewer")
library("WGCNA")
library("flashClust")
library("gridExtra")
library("ComplexHeatmap")
library("goseq")
library("dplyr")
library("clusterProfiler")
library("pheatmap")
library("magrittr")
library("dendsort")
library("MetaboAnalystR")
```

This script uses WGCNA analysis on metabolomics data set to explore whether we can detect "modules" of genes that are correlated with lifestage. PLS-DA analyses and multivariate analyses are conducted in metabolomics.Rmd script. The pipeline in this script is modified from K. Wong script: 

# Pipeline Overview

1. Data preparation
  + Load and format clean data
  + Data filtering: PoverA and genefilter
  + Outlier detection
2. Network construction and consensus module detection
  + Choosing a soft-thresholding power: Analysis of a network topology β  
  + Identify modules using blockwiseModules  
  + Relate modules to sample information  
  + Relate modules to life stage
3. Plot module-trait associations
4. Plot mean eigengene values for each module  
5. Pathway analysis    

# 1. Data Preparation  

## Load and format clean data  

Read in data file and create metadata with sample information as well as a count matrix with metabolite counts. Data will be read in from "selected metabolites" dataset that has already undergone polarity selection, cleaning metabolite names, and median-centered normalized ion counts in the metabolomics.Rmd script.  

```{r}
data<-read.csv("Mcap2020/Output/Metabolomics/selected_metabolites.csv")

metadata<-data%>%
  select(Lifestage, Rep, HPF, Development)%>%
  mutate(Sample=paste(Lifestage, Rep, sep="-"))

metadata<-metadata[1:47,] #reduce to just one set of metadata 

data<-data%>%
  mutate(Sample=paste(Lifestage, Rep, sep="-"))%>%
  select(Sample, compound, norm_counts)
```

Convert the data table to a wide format with samples in columns and metabolites in rows.  

```{r}
data<-data%>%
  spread(Sample, norm_counts)

head(data)

rownames(data)<-data$compound

data<-data%>%
  select(-compound)
```

Check that there are no metabolites with 0 counts for all samples. Should return TRUE.  

```{r}
rowSums(dplyr::count(data)) > 0
```

## Data filtering: PoverA and genefilter  

Conduct data filtering, this includes:  

*pOverA*: Specifying the minimum count for a proportion of samples for each metabolite. Here, we are using a pOverA of 0.07. This is because we have 46 samples with a minimum of n=2 samples per lifestage. Therefore, we will accept genes that are present in 2/46 = 0.04 of the samples because we expect different metabolites by life stage as demonstrated by PLSDA analysis (as analyzed in metabolomics.Rmd). We are further setting the minimum value of metabolites to 1 (median normalized), such that 4% of the samples must have a non-zero normalized metabolite presence in order for the metabolite to remain in the data set.  

Filter in the package "genefilter". Pre-filtering our dataset to reduce the memory size dataframe, increase the speed of the transformation and testing functions, and improve quality of statistical analysis by removing low-coverage counts. Removed counts could represent outliers in the data and removing these improves sensitivity of statistical tests.   

```{r}
filt <- filterfun(pOverA(0.04,0.01))

#create filter for the counts data
gfilt <- genefilter(data, filt)

#identify genes to keep by count filter
keep <- data[gfilt,]

#identify gene lists
n.keep <- rownames(keep)

#gene count data filtered in PoverA, P percent of the samples have counts over A
data_filt <- as.data.frame(data[which(rownames(data) %in% n.keep),])

#How many rows do we have before and after filtering?
nrow(data) #Before
nrow(data_filt) #After
```

Filtering does not remove any metabolites, all 182 metabolites are used in analysis.  

Check that all row and column names match. Should return TRUE.  
```{r}
#Checking that all row and column names match. Should return "TRUE"
all(rownames(metadata$sample_id) %in% colnames(data_filt))
all(rownames(metadata$sample_id) == colnames(data_filt)) 
```

## Outlier detection  

Look for outliers by examining tree of metabolites  
```{r}
sampleTree = hclust(dist(data_filt), method = "average");
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
# The user should change the dimensions if the window is too large or too small.
pdf("Mcap2020/Figures/Metabolomics/WGCNA/outliers_metabolites.pdf")
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)
dev.off()
```

Betaine could be a large outlier, likely due to very high abundance compared to other metabolites. Try analysis with and without Betaine. Proceeding now without removing Betaine.    

```{r}
outlier<-c("Betaine")
#data_filt<-data_filt%>%
  #filter(!row.names(data_filt) %in% outlier)
```

Now look at the tree again.   
```{r}
sampleTree = hclust(dist(data_filt), method = "average");
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
# The user should change the dimensions if the window is too large or too small.
pdf("Mcap2020/Figures/Metabolomics/WGCNA/outliers_metabolites_filt.pdf")
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)
dev.off()
```

Transpose such that samples are in rows and metabolites are in columns.  

```{r}
data_filt <- t(data_filt) 
```

Look for outlier samples by examining tree of samples  
```{r}
sampleTree = hclust(dist(data_filt), method = "average");
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
# The user should change the dimensions if the window is too large or too small.
pdf("Mcap2020/Figures/Metabolomics/WGCNA/outliers_samples.pdf")
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)
dev.off()
```

No clear outliers.  


# 2. Network construction and consensus module detection  

## Choosing a soft-thresholding power: Analysis of network topology β  

The soft thresholding power (β) is the number to which the co-expression similarity is raised to calculate adjacency. The function pickSoftThreshold performs a network topology analysis. The user chooses a set of candidate powers, however the default parameters are suitable values.  
```{r, message=FALSE, warning=FALSE}
# # Choose a set of soft-thresholding powers
allowWGCNAThreads()

powers <- c(c(1:20), seq(from = 12, to=20, by=2)) #Create a string of numbers from 1 through 10, and even numbers from 10 through 20
# 
# # Call the network topology analysis function
sft <-pickSoftThreshold(data_filt, powerVector = powers, verbose = 5)
```

Plot the results.  
```{r}
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# # # Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
      xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
 text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# # # this line corresponds to using an R^2 cut-off
 abline(h=0.8,col="red")
# # # Mean connectivity as a function of the soft-thresholding power
 plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
 text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
```

From this data, it appears that our **soft thresholding power is 7**.  

## Identify modules using blockwiseModules  

Use blockwiseModules to identify modules of metabolites.  

Settings used: **Add explanations to this**  

networkType = "unsigned" 
deepSplit = 2
pamRespectsDendro = F
minModuleSize = 5
maxBlockSize = 4000
reassignThreshold = 0
mergeCutHeight = 0.25

Need to change RData output 

``` {r, echo=TRUE, warning=FALSE, message=FALSE}

picked_power = 7
temp_cor <- cor       
cor <- WGCNA::cor                                             # Force it to use WGCNA cor function (fix a namespace conflict issue)
netwk <- blockwiseModules(data_filt,                         # <= input here

                          # == Adjacency Function ==
                          power = picked_power,               # <= power here
                          networkType = "unsigned",

                          # == Tree and Block Options ==
                          deepSplit = 2,
                          pamRespectsDendro = F,
                          # detectCutHeight = 0.75,
                          minModuleSize = 5,                  #consider increasing or decreasing this
                          maxBlockSize = 4000,

                          # == Module Adjustments ==
                          reassignThreshold = 0,
                          mergeCutHeight = 0.25,

                          # == TOM == Archive the run results in TOM file (saves time) but it doesn't save a file
                          saveTOMs = F,
                          saveTOMFileBase = "ER",

                          # == Output Options
                          numericLabels = T,
                          verbose = 3)

cor <- temp_cor     # Return cor function to original namespace

# Identify labels as numbers 
mergedColors = netwk$colors
# Plot the dendrogram and the module colors underneath

pdf("Mcap2020/Figures/Metabolomics/WGCNA/blockwise_module_colors.pdf")
plotDendroAndColors(
  netwk$dendrograms[[1]],
  mergedColors[netwk$blockGenes[[1]]],
  "Module colors",
  dendroLabels = FALSE,
  hang = 0.03,
  addGuide = TRUE,
  guideHang = 0.05 )
dev.off()
```

## Relate modules to sample information  

``` {r, echo=TRUE, warning=FALSE, message=FALSE}
module_df <- data.frame(
  Metabolite = names(netwk$colors),
  colors = netwk$colors
  #colors = labels2colors(netwk$colors)
)

module_df[1:5,]

write.csv(module_df, "Mcap2020/Output/Metabolomics/WGCNA/metabolite_modules.csv")

# Get Module Eigengenes per cluster
MEs <- moduleEigengenes(data_filt, mergedColors)$eigengenes

# Reorder modules so similar modules are next to each other
MEs <- orderMEs(MEs)
module_order = names(MEs) %>% gsub("ME","", .)

# Add Sample names
MEs0 <- MEs
MEs0$Sample.ID = row.names(MEs)

# tidy & plot data
mME = MEs0 %>%
  pivot_longer(-Sample.ID) %>%
  mutate(
    name = gsub("ME", "", name),
    name = factor(name, levels = module_order)
  )

mME %>% ggplot(., aes(x=Sample.ID, y=name, fill=value)) +
  geom_tile() +
  theme_bw() +
  scale_fill_gradient2(
    low = "blue",
    high = "red",
    mid = "white",
    midpoint = 0,
    limit = c(-1,1)) +
  theme(axis.text.x = element_text(angle=90)) +
  labs(title = "Module-Sample Relationships", y = "Modules", fill="corr")
```


## Relate modules to life stage  

Prepare trait data. Data has to be numeric, so I will substitute time points/developmental stages for numeric values. The "trait" we are considering here is lifestage. Make a dataframe that has a column for each lifestage name and a row for samples. Populate a 1 for samples that match each lifestage and a 0 for samples not matching respective lifestages. This process changes lifestages from a categorical variable into a binary variable. This will allow for correlations between mean eigengenes and lifestage.  
 
```{r}
metadata$num <- c("1")
allTraits <- as.data.frame(pivot_wider(metadata, names_from = Lifestage, values_from = num, id_cols = Sample))
allTraits[is.na(allTraits)] <- c("0")
rownames(allTraits) <- allTraits$Sample
datTraits <- allTraits[,c(-1)]
head(datTraits)

#define numbers of metabolites and samples and view 
nMetabolites = ncol(data_filt)
nSamples = nrow(data_filt)

nMetabolites
nSamples
```

We have 182 metabolites and 47 samples.   

Next correlate the trait of life stage with eigengenes (modules).  

```{r}
# Correlations of traits with eigengenes
moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);
Colors=sub("ME","", names(MEs))
moduleTraitTree = hclust(dist(t(moduleTraitCor)), method = "average")
pdf(file="Mcap2020/Figures/Metabolomics/WGCNA/ModuleTraitClusterTree.pdf", height=8, width=22)
plot(moduleTraitTree)
dev.off()

# Correlations of metabolites with eigengenes. Calculate correlations between ME's and groups 
moduleGeneCor=cor(MEs,data_filt)
moduleGenePvalue = corPvalueStudent(moduleGeneCor, nSamples);
head(moduleGenePvalue)
```

## Plot module-trait associations

Represent module trait correlations as a heatmap.  
```{r, echo=TRUE, warning=FALSE, message=FALSE}
textMatrix = paste(signif(moduleTraitCor, 2), "\n(",signif(moduleTraitPvalue, 1), ")", sep = "")
dim(textMatrix) = dim(moduleTraitCor)
head(textMatrix)
labeledHeatmap(Matrix = moduleTraitCor, xLabels = names(datTraits),  yLabels = names(MEs), ySymbols = names(MEs), cex.lab.y= 0.55, cex.lab.x= 0.55, colors = blueWhiteRed(50), textMatrix = textMatrix, setStdMargins = TRUE, cex.text = 0.25, textAdj = , zlim = c(-1,1), main = paste("Module-trait relationships"))
pdf(file="Mcap2020/Figures/Metabolomics/WGCNA/Module-trait-relationships.pdf")
labeledHeatmap(Matrix = moduleTraitCor, xLabels = names(datTraits),  yLabels = names(MEs), ySymbols = names(MEs), cex.lab.y= 0.55, cex.lab.x= 0.55, colors = blueWhiteRed(50), textMatrix = textMatrix, setStdMargins = TRUE, cex.text = 0.25, textAdj = , zlim = c(-1,1), main = paste("Module-trait relationships"))
dev.off()

```

# 3. Plot module triat associations with a complex heatmap   

```{r, echo=TRUE, warning=FALSE, message=FALSE}
#bold sig p-values
#dendrogram with WGCNA MEtree cut-off
#colored y-axis
#Create list of pvalues for eigengene correlation with specific life stages
heatmappval <- signif(moduleTraitPvalue, 1)
#Make list of heatmap row colors
htmap.colors <- names(MEs)
htmap.colors <- gsub("ME", "", htmap.colors)

row_dend = dendsort(hclust(dist(moduleTraitCor)))
col_dend = dendsort(hclust(dist(t(moduleTraitCor))))


#row_ha = rowAnnotation(ModuleSize = anno_text("11", "127", "8", "64", "85"), just = "left", 
#        location = unit(0.5, "npc"), show_name = TRUE)
# brown (11), grey (127), yellow (8), blue (64), turqoise (85) #figure out how to do row annotations to add sample sizes

pdf(file = "Mcap2020/Figures/Metabolomics/WGCNA/Module-trait-relationship-heatmap.pdf", height = 8, width = 8)
ht=Heatmap(moduleTraitCor, name = "Eigengene", column_title = "Module-Group Eigengene Correlation", 
        col = blueWhiteRed(50), 
        row_names_side = "left", 
        row_dend_side = "left",
        width = unit(5, "in"), 
        height = unit(4.5, "in"), 
        column_dend_reorder = TRUE, 
        cluster_columns = col_dend,
        row_dend_reorder = FALSE,
        column_split = 4, 
        row_split = 3, 
        column_dend_height = unit(.5, "in"),
        cluster_rows = row_dend, 
        row_gap = unit(2.5, "mm"), 
        border = TRUE,
        cell_fun = function(j, i, x, y, w, h, col) {
        if(heatmappval[i, j] < 0.05) {
            grid.text(sprintf("%s", heatmappval[i, j]), x, y, gp = gpar(fontsize = 10, fontface = "bold"))
        }
        else {
            grid.text(sprintf("%s", heatmappval[i, j]), x, y, gp = gpar(fontsize = 10, fontface = "plain"))
        }},
        column_names_gp =  gpar(fontsize = 12, border=FALSE),
        row_names_gp = gpar(fontsize = 12, alpha = 0.75, border = FALSE))
draw(ht)
dev.off()
```


# 4. Plot mean eigengene values for each module

Load metadata and plot expression plots.  
```{r, echo=TRUE, warning=FALSE, message=FALSE}

# Number of each metabolites in each module 
row_mod_num <- data.frame(table(module_df$colors)) 

# Bring in additional metadata

sample_metadata <- read.csv("Mcap2020/Data/Metabolomics/metabolomics_meta_wgcna.csv") 

sample_metadata$Sample.ID <- as.factor(sample_metadata$Sample.ID)
sample_metadata$lifestage <- as.factor(sample_metadata$lifestage)
sample_metadata$hpf <- as.factor(sample_metadata$hpf)
sample_metadata$group <- as.factor(sample_metadata$group)

mME_meta <- merge(mME, sample_metadata, by = "Sample.ID") %>%
  rename(Module = name)
```

Add module "cluster" categories determined by WGCNA above.  
```{r}
mME_meta<-mME_meta%>%
  mutate(Cluster=if_else(Module == "2", "Cluster1", 
                               if_else(Module =="5", "Cluster1", 
                                       if_else(Module == "0", "Cluster1", 
                                               if_else(Module == "7", "Cluster2",
                                               if_else(Module=="6", "Cluster2", 
                                                       if_else(Module == "3", "Cluster2", 
                                                       if_else(Module == "1", "Cluster3", 
                                                               if_else(Module == "8", "Cluster3",
                                                               if_else(Module == "4", "Cluster3", "NA"))))))))))

mME_meta$Cluster<-as.factor(mME_meta$Cluster)
```


Plot by time point with individual modules.  
```{r}

mME_meta$group <- factor(mME_meta$group, levels = c("Egg", "Embryo", "Larvae", "Metamorphosed Recruit", "Attached Recruit"))
mME_meta$Module <- factor(mME_meta$Module, levels = c("0", "1", "2", "3", "4", "5", "6", "7", "8"))

expression_plots<-mME_meta%>%
#  group_by(Module) %>%
  ggplot(aes(x=hpf, y=value, fill=group)) +
  facet_wrap(~ Module)+
  ylab("Mean Module Eigenegene Value") +
  geom_hline(yintercept = 0, linetype="dashed", color = "grey")+
  geom_boxplot(width=.5, outlier.shape= NA, position = position_dodge(width = 0.5), alpha = 0.7) +
  stat_summary(fun=mean, geom="line", aes(group=lifestage, color = group), position = position_dodge(width = 0.5))  + 
  geom_point(pch = 21, position = position_dodge(width = 0.5)) +
  scale_fill_manual(name="Lifestage", values=c("#8C510A", "#DFC27D","#80CDC1", "#003C30", "#BA55D3")) +
  scale_color_manual(name="Lifestage", values=c("#8C510A", "#DFC27D","#80CDC1", "#003C30", "#BA55D3")) + 
  xlab("Hours Post-Fertilization") + #Axis titles
  theme_bw() + theme(panel.border = element_rect(color="black", fill=NA, size=0.75), panel.grid.major = element_blank(), #Makes background theme white
                     panel.grid.minor = element_blank(), axis.line = element_blank()) +
  theme(axis.text = element_text(size = 11 , color = "black"),
        axis.title = element_text(size = 16, color = "black"), 
        axis.text.x = element_text(size=11, color="black"), 
        legend.title=element_blank(), 
        legend.text=element_text(color="black", size=12)); expression_plots

ggsave(filename="Mcap2020/Figures//Metabolomics/WGCNA/expression_eigengene.jpeg", plot=expression_plots, dpi=300, width=12, height=8, units="in")

```

Plot by time point with module clusters.  
```{r}
mME_meta$group <- factor(mME_meta$group, levels = c("Egg", "Embryo", "Larvae", "Metamorphosed Recruit", "Attached Recruit"))
mME_meta$Cluster <- factor(mME_meta$Cluster, levels = c("Cluster1", "Cluster2", "Cluster3"))

expression_plots_cluster<-mME_meta%>%
#  group_by(Module) %>%
  ggplot(aes(x=hpf, y=value, fill=group)) +
  facet_grid(Cluster ~.)+
  ylab("Mean Module Cluster Eigenegene Value") +
  geom_hline(yintercept = 0, linetype="dashed", color = "grey")+
  geom_boxplot(width=.5, outlier.shape= NA, position = position_dodge(width = 0.5), alpha = 0.7) +
  stat_summary(fun=mean, geom="line", aes(group=lifestage, color = group), position = position_dodge(width = 0.5))  + 
  geom_point(pch = 21, position = position_dodge(width = 0.5)) +
  scale_fill_manual(name="Lifestage", values=c("#8C510A", "#DFC27D","#80CDC1", "#003C30", "#BA55D3")) +
  scale_color_manual(name="Lifestage", values=c("#8C510A", "#DFC27D","#80CDC1", "#003C30", "#BA55D3")) + 
  xlab("Hours Post-Fertilization") + #Axis titles
  theme_bw() + theme(panel.border = element_rect(color="black", fill=NA, size=0.75), panel.grid.major = element_blank(), #Makes background theme white
                     panel.grid.minor = element_blank(), axis.line = element_blank()) +
  theme(axis.text = element_text(size = 11 , color = "black"),
        axis.title = element_text(size = 16, color = "black"), 
        axis.text.x = element_text(size=11, color="black"), 
        legend.position="top", 
        legend.title=element_blank(), 
        legend.text=element_text(color="black", size=12), 
        strip.text.y = element_text(size = 14, color = "black", face = "bold.italic")); expression_plots_cluster

ggsave(filename="Mcap2020/Figures//Metabolomics/WGCNA/expression_eigengene_cluster.jpeg", plot=expression_plots_cluster, dpi=300, width=7, height=10, units="in")

``` 


# 5. Pathway Analysis  


THIS SCRIPT CURRENTLY WILL NOT RUN DUE TO DOWNLOADING ERRORS WITH CURL



Conduct pathway anlaysis for each module cluster - clusters 1, 2, and 3 as determined by WGCNA analysis above.  

First, generate a list of metabolites contained within each module cluster.  

```{r, echo=TRUE, warning=FALSE, message=FALSE}

module_df <- read.csv("Mcap2020/Output/Metabolomics/WGCNA/metabolite_modules.csv")

module_df <- module_df %>% rename(Module = colors)

# Select metabolites for each module 
cluster1<-c("2", "5", "0")
cluster2<-c("7", "6", "3")
cluster3<-c("1", "8", "4")

module_cluster1 <- module_df %>% filter(Module %in% cluster1)  %>% select(Metabolite)
module_cluster2 <- module_df %>% filter(Module %in% cluster2)  %>% select(Metabolite)
module_cluster3 <- module_df %>% filter(Module %in% cluster3)  %>% select(Metabolite)
```

Cluster 1 = 53 metabolites
Cluster 2 = 41 metabolites
Cluster 3 = 88 metabolites 

Conduct pathway analysis in Metaboanalyst. For compounds that do not match in the database, they are manually renamed here as determined using the Metaboanalyst web interface.  

Conduct enrichment analysis for Cluster 1 and save data frame with KEGG terms.  
```{r}
library(curl)
# Enrichment analysis for cluster 1 modules
mSet_c1 <-InitDataObjects("conc", "msetora", FALSE)
cmpd.vec<-c(module_cluster1$Metabolite)
mSet_c1<-Setup.MapData(mSet_c1, cmpd.vec)

lib.url <- paste("https://www.metaboanalyst.ca/resources/libs/", "compound_db.qs", sep = "")

compound_db.rds<-readRDS("Mcap2020/Data/Metabolomics/compound_db.rds")
my.lib<-"Mcap2020/Data/Metabolomics/compound_db.qs"
mSet_c1<-CrossReferencing(mSet_c1, "name")




mSet_c1<-CreateMappingResultTable(mSet_c1)
mSet_c1<-GetCandidateList(mSet_c1)
mSet_c1[["name.map"]][["hit.values"]]
mSet_c1<-SetMetabolomeFilter(mSet_c1, F)

mSet_c1<-Setup.MapData(mSet_c1, cmpd.vec);
mSet_c1<-CrossReferencing(mSet_c1, "name");
mSet_c1<-CreateMappingResultTable(mSet_c1)
mSet_c1<-PerformDetailMatch(mSet_c1, "1-Methylimidazole acetic acid");
mSet_c1<-GetCandidateList(mSet_c1);
mSet_c1<-SetCandidate(mSet_c1, "1-Methylimidazole acetic acid", "Methylimidazoleacetic acid");
mSet_c1<-PerformDetailMatch(mSet_c1, "3-Indo-L-tyrosine");
mSet_c1<-GetCandidateList(mSet_c1);
mSet_c1<-SetCandidate(mSet_c1, "3-Indo-L-tyrosine", "Iodotyrosine");
mSet_c1<-PerformDetailMatch(mSet_c1, "3-Phenylbutyric acid");
mSet_c1<-GetCandidateList(mSet_c1);
mSet_c1<-SetCandidate(mSet_c1, "3-Phenylbutyric acid", "3-Phenylbutyric acid");
mSet_c1<-PerformDetailMatch(mSet_c1, "3-Indo-L-tyrosine");
mSet_c1<-GetCandidateList(mSet_c1);
mSet_c1<-PerformDetailMatch(mSet_c1, "4-Guanidinobutanoic acid");
mSet_c1<-GetCandidateList(mSet_c1);
mSet_c1<-SetCandidate(mSet_c1, "4-Guanidinobutanoic acid", "4-Guanidinobutanoic acid");
mSet_c1<-PerformDetailMatch(mSet_c1, "Acetyl glycine");
mSet_c1<-GetCandidateList(mSet_c1);
mSet_c1<-SetCandidate(mSet_c1, "Acetyl glycine", "Acetylglycine");
mSet_c1<-PerformDetailMatch(mSet_c1, "Adipic acid");
mSet_c1<-GetCandidateList(mSet_c1);
mSet_c1<-SetCandidate(mSet_c1, "Adipic acid", "Oxoadipic acid");
mSet_c1<-PerformDetailMatch(mSet_c1, "Arginine-Valine");
mSet_c1<-GetCandidateList(mSet_c1);
mSet_c1<-SetCandidate(mSet_c1, "Arginine-Valine", "Arginyl-Valine");
mSet_c1<-PerformDetailMatch(mSet_c1, "Carbamoyl phosphate");
mSet_c1<-GetCandidateList(mSet_c1);
mSet_c1<-SetCandidate(mSet_c1, "Carbamoyl phosphate", "Carbamoyl phosphate");
mSet_c1<-PerformDetailMatch(mSet_c1, "Cyclic AMP");
mSet_c1<-GetCandidateList(mSet_c1);
mSet_c1<-SetCandidate(mSet_c1, "Cyclic AMP", "Cyclic AMP");
mSet_c1<-PerformDetailMatch(mSet_c1, "Glucuronic acid");
mSet_c1<-GetCandidateList(mSet_c1);
mSet_c1<-SetCandidate(mSet_c1, "Glucuronic acid", "D-Glucuronic acid");
mSet_c1<-PerformDetailMatch(mSet_c1, "Glutaric acid");
mSet_c1<-GetCandidateList(mSet_c1);
mSet_c1<-SetCandidate(mSet_c1, "Glutaric acid", "Glutaric acid");
mSet_c1<-PerformDetailMatch(mSet_c1, "Glutaryl-carnitine");
mSet_c1<-GetCandidateList(mSet_c1);
mSet_c1<-SetCandidate(mSet_c1, "Glutaryl-carnitine", "Glutamylarginine");
mSet_c1<-PerformDetailMatch(mSet_c1, "Hippuric acid");
mSet_c1<-GetCandidateList(mSet_c1);
mSet_c1<-SetCandidate(mSet_c1, "Hippuric acid", "Hippuric acid");
mSet_c1<-PerformDetailMatch(mSet_c1, "Hydroxyoctanoic acid");
mSet_c1<-GetCandidateList(mSet_c1);
mSet_c1<-SetCandidate(mSet_c1, "Hydroxyoctanoic acid", "7-Hydroxyoctanoic acid");
mSet_c1<-PerformDetailMatch(mSet_c1, "Malonic acid");
mSet_c1<-GetCandidateList(mSet_c1);
mSet_c1<-SetCandidate(mSet_c1, "Malonic acid", "Malonic acid");
mSet_c1<-PerformDetailMatch(mSet_c1, "Methylphenyllactate");
mSet_c1<-GetCandidateList(mSet_c1);
mSet_c1<-SetCandidate(mSet_c1, "Methylphenyllactate", "3-Methylphenylacetic acid");
mSet_c1<-PerformDetailMatch(mSet_c1, "N-carbomoyl-L-aspartate");
mSet_c1<-GetCandidateList(mSet_c1);
mSet_c1<-SetCandidate(mSet_c1, "N-carbomoyl-L-aspartate", "Ureidosuccinic acid");
mSet_c1<-PerformDetailMatch(mSet_c1, "NG-dimethyl-L-arginine");
mSet_c1<-GetCandidateList(mSet_c1);
mSet_c1<-SetCandidate(mSet_c1, "NG-dimethyl-L-arginine", "Asymmetric dimethylarginine");
mSet_c1<-PerformDetailMatch(mSet_c1, "Ribose phosphate");
mSet_c1<-GetCandidateList(mSet_c1);
mSet_c1<-SetCandidate(mSet_c1, "Ribose phosphate", "Ribose 1-phosphate");
mSet_c1<-PerformDetailMatch(mSet_c1, "Uric acid");
mSet_c1<-GetCandidateList(mSet_c1);
mSet_c1<-SetCandidate(mSet_c1, "Uric acid", "Uric acid");

mSet_c1<-SetMetabolomeFilter(mSet_c1, F);
mSet_c1<-SetCurrentMsetLib(mSet_c1, "kegg_pathway", 2);
mSet_c1<-CalculateHyperScore(mSet_c1)
mSet_c1<-PlotORA(mSet_c1, "ora_0_", "net", "png", 72, width=NA)
mSet_c1<-PlotEnrichDotPlot(mSet_c1, "ora", "ora_dot_0_", "png", 72, width=NA)
mSet_c1<-CalculateHyperScore(mSet_c1)
mSet_c1<-PlotORA(mSet_c1, "ora_1_", "net", "png", 72, width=NA)
mSet_c1<-PlotEnrichDotPlot(mSet_c1, "ora", "ora_dot_1_", "png", 72, width=NA)
mSet_c1<-SetMetabolomeFilter(mSet_c1, F);
mSet_c1<-SetCurrentMsetLib(mSet_c1, "main_class", 2);
mSet_c1<-CalculateHyperScore(mSet_c1)
mSet_c1<-PlotORA(mSet_c1, "ora_2_", "net", "png", 72, width=NA)
mSet_c1<-PlotEnrichDotPlot(mSet_c1, "ora", "ora_dot_2_", "png", 72, width=NA)
mSet_c1<-PlotEnrichPieChart(mSet_c1, "ora", "ora_pie_0_", "png", 72)
mSet_c1<-CalculateHyperScore(mSet_c1)
mSet_c1<-PlotORA(mSet_c1, "ora_3_", "net", "png", 72, width=NA)
mSet_c1<-PlotEnrichDotPlot(mSet_c1, "ora", "ora_dot_3_", "png", 72, width=NA)
mSet_c1<-PlotEnrichPieChart(mSet_c1, "ora", "ora_pie_1_", "png", 72)
```















```{r}
mSet_c1<-Setup.MapData(mSet_c1, cmpd.vec)
mSet_c1<-CrossReferencing(mSet_c1, "name")
mSet_c1<-CreateMappingResultTable(mSet_c1)
mSet_c1<-GetCandidateList(mSet_c1)
mSet_c1[["name.map"]][["hit.values"]]
mSet_c1<-SetMetabolomeFilter(mSet_c1, F)

mSet_cluster1_dataset <- mSet_c1$dataSet #extracting input dataframe
mSet_brown_KEGG <- as.data.frame(mSet_brown_dataset$map.table) #extracting KEGG terms
write.csv(mSet_brown_KEGG, "../../output/Metabolomics/MetaboAnalyst/mSet_brown_KEGG.csv")

mSet_c1<-SetCurrentMsetLib(mSet_c1, "kegg_pathway", 2)
mSet_c1<-CalculateHyperScore(mSet_c1)
mSet_c1_Path_KEGG <- mSet_c1$api
mSet_c1_ora <- as.data.frame(mmSet_c1_Path_KEGG$ora.results)
write.csv(mSet_brown_ora, "Mcap2020/Output/Metabolomics/MetaboAnalyst/mSet_brown_ora.csv")

#Figure out how to print associated metabolites for each pathway. Ideally print a column in the mSet_brown_ora with a metabolites column
#mSet_c1[["analSet"]][["ora.hits"]][["Galactose metabolism"]]




mSet<-InitDataObjects("conc", "msetora", FALSE)
cmpd.vec<-c("1-Methylimidazole acetic acid","3-Indo-L-tyrosine","3-Phenylbutyric acid","4-Aminobutyrate","4-Guanidinobutanoic acid","5-Methylcytosine","Acetyl glycine","Adipic acid","Alanine","Arginine-Valine","Betaine","Carbamoyl phosphate","Creatinine","Cyclic AMP","Deoxyadenosine","Deoxycarnitine","Deoxyguanosine","Diethanolamine","Fumarate","Glucuronic acid","Glutaric acid","Glutaryl-carnitine","Glycerol-3-phosphate","Glycerophosphocholine","Glycine","Glycyl-L-proline","Guanine","Hippuric acid","Hydroxyoctanoic acid","IMP","Indole","Isocitrate","Isoleucine","L-Octanoylcarnitine","Lumichrome","Malonic acid","Methylphenyllactate","N-Acetylaspartate","N-carbomoyl-L-aspartate","N-octanoylglycine","NAADP","NG-dimethyl-L-arginine","O-Decanoyl-L-carnitine","Ornithine","Phosphoenolpyruvate","Porphobilinogen","Pterin","Ribose phosphate","Succinate","Taurine","Thiamine","Threonine","Uric acid")
mSet<-Setup.MapData(mSet, cmpd.vec);
mSet<-CrossReferencing(mSet, "name");
mSet<-CreateMappingResultTable(mSet)
mSet<-PerformDetailMatch(mSet, "1-Methylimidazole acetic acid");
mSet<-GetCandidateList(mSet);
mSet<-SetCandidate(mSet, "1-Methylimidazole acetic acid", "Methylimidazoleacetic acid");
mSet<-PerformDetailMatch(mSet, "3-Indo-L-tyrosine");
mSet<-GetCandidateList(mSet);
mSet<-SetCandidate(mSet, "3-Indo-L-tyrosine", "Iodotyrosine");
mSet<-PerformDetailMatch(mSet, "3-Phenylbutyric acid");
mSet<-GetCandidateList(mSet);
mSet<-SetCandidate(mSet, "3-Phenylbutyric acid", "3-Phenylbutyric acid");
mSet<-PerformDetailMatch(mSet, "3-Indo-L-tyrosine");
mSet<-GetCandidateList(mSet);
mSet<-SetCandidate(mSet, "3-Indo-L-tyrosine", "Iodotyrosine");
mSet<-SetCandidate(mSet, "3-Indo-L-tyrosine", "Iodotyrosine");
mSet<-PerformDetailMatch(mSet, "4-Guanidinobutanoic acid");
mSet<-GetCandidateList(mSet);
mSet<-SetCandidate(mSet, "4-Guanidinobutanoic acid", "4-Guanidinobutanoic acid");
mSet<-PerformDetailMatch(mSet, "Acetyl glycine");
mSet<-GetCandidateList(mSet);
mSet<-SetCandidate(mSet, "Acetyl glycine", "Acetylglycine");
mSet<-PerformDetailMatch(mSet, "Adipic acid");
mSet<-GetCandidateList(mSet);
mSet<-SetCandidate(mSet, "Adipic acid", "Oxoadipic acid");
mSet<-PerformDetailMatch(mSet, "Arginine-Valine");
mSet<-GetCandidateList(mSet);
mSet<-SetCandidate(mSet, "Arginine-Valine", "Arginyl-Valine");
mSet<-PerformDetailMatch(mSet, "Carbamoyl phosphate");
mSet<-GetCandidateList(mSet);
mSet<-SetCandidate(mSet, "Carbamoyl phosphate", "Carbamoyl phosphate");
mSet<-PerformDetailMatch(mSet, "Cyclic AMP");
mSet<-GetCandidateList(mSet);
mSet<-SetCandidate(mSet, "Cyclic AMP", "Cyclic AMP");
mSet<-PerformDetailMatch(mSet, "3-Indo-L-tyrosine");
mSet<-GetCandidateList(mSet);
mSet<-SetCandidate(mSet, "3-Indo-L-tyrosine", "Iodotyrosine");
mSet<-PerformDetailMatch(mSet, "Glucuronic acid");
mSet<-GetCandidateList(mSet);
mSet<-SetCandidate(mSet, "Glucuronic acid", "D-Glucuronic acid");
mSet<-PerformDetailMatch(mSet, "Glutaric acid");
mSet<-GetCandidateList(mSet);
mSet<-SetCandidate(mSet, "Glutaric acid", "Glutaric acid");
mSet<-PerformDetailMatch(mSet, "Glutaryl-carnitine");
mSet<-GetCandidateList(mSet);
mSet<-SetCandidate(mSet, "Glutaryl-carnitine", "Glutamylarginine");
mSet<-PerformDetailMatch(mSet, "Hippuric acid");
mSet<-GetCandidateList(mSet);
mSet<-SetCandidate(mSet, "Hippuric acid", "Hippuric acid");
mSet<-PerformDetailMatch(mSet, "Hydroxyoctanoic acid");
mSet<-GetCandidateList(mSet);
mSet<-SetCandidate(mSet, "Hydroxyoctanoic acid", "7-Hydroxyoctanoic acid");
mSet<-PerformDetailMatch(mSet, "Malonic acid");
mSet<-GetCandidateList(mSet);
mSet<-SetCandidate(mSet, "Malonic acid", "Malonic acid");
mSet<-PerformDetailMatch(mSet, "Methylphenyllactate");
mSet<-GetCandidateList(mSet);
mSet<-SetCandidate(mSet, "Methylphenyllactate", "3-Methylphenylacetic acid");
mSet<-PerformDetailMatch(mSet, "N-carbomoyl-L-aspartate");
mSet<-GetCandidateList(mSet);
mSet<-SetCandidate(mSet, "N-carbomoyl-L-aspartate", "Ureidosuccinic acid");
mSet<-PerformDetailMatch(mSet, "NG-dimethyl-L-arginine");
mSet<-GetCandidateList(mSet);
mSet<-SetCandidate(mSet, "NG-dimethyl-L-arginine", "Asymmetric dimethylarginine");
mSet<-PerformDetailMatch(mSet, "Ribose phosphate");
mSet<-GetCandidateList(mSet);
mSet<-SetCandidate(mSet, "Ribose phosphate", "Ribose 1-phosphate");
mSet<-PerformDetailMatch(mSet, "Uric acid");
mSet<-GetCandidateList(mSet);
mSet<-SetCandidate(mSet, "Uric acid", "Uric acid");
mSet<-PerformDetailMatch(mSet, "3-Indo-L-tyrosine");
mSet<-GetCandidateList(mSet);
mSet<-SetCandidate(mSet, "3-Indo-L-tyrosine", "3,5-Diiodo-L-tyrosine");
mSet<-SetMetabolomeFilter(mSet, F);
mSet<-SetCurrentMsetLib(mSet, "kegg_pathway", 2);
mSet<-CalculateHyperScore(mSet)
mSet<-PlotORA(mSet, "ora_0_", "net", "png", 72, width=NA)
mSet<-PlotEnrichDotPlot(mSet, "ora", "ora_dot_0_", "png", 72, width=NA)
mSet<-CalculateHyperScore(mSet)
mSet<-PlotORA(mSet, "ora_1_", "net", "png", 72, width=NA)
mSet<-PlotEnrichDotPlot(mSet, "ora", "ora_dot_1_", "png", 72, width=NA)
mSet<-SetMetabolomeFilter(mSet, F);
mSet<-SetCurrentMsetLib(mSet, "main_class", 2);
mSet<-CalculateHyperScore(mSet)
mSet<-PlotORA(mSet, "ora_2_", "net", "png", 72, width=NA)
mSet<-PlotEnrichDotPlot(mSet, "ora", "ora_dot_2_", "png", 72, width=NA)
mSet<-PlotEnrichPieChart(mSet, "ora", "ora_pie_0_", "png", 72)
mSet<-CalculateHyperScore(mSet)
mSet<-PlotORA(mSet, "ora_3_", "net", "png", 72, width=NA)
mSet<-PlotEnrichDotPlot(mSet, "ora", "ora_dot_3_", "png", 72, width=NA)
mSet<-PlotEnrichPieChart(mSet, "ora", "ora_pie_1_", "png", 72)






```

Conduct enrichment analysis for Cluster 2 and save data frame with KEGG terms.  
```{r}
# Enrichment analysis for Yellow module

mSet_yellow <-InitDataObjects("conc", "msetora", FALSE)
cmpd.vec.yellow<-c(module_yellow$Metabolite)
mSet_yellow<-Setup.MapData(mSet_yellow, cmpd.vec.yellow)
mSet_yellow<-CrossReferencing(mSet_yellow, "name")
mSet_yellow<-CreateMappingResultTable(mSet_yellow)
mSet_yellow<-GetCandidateList(mSet_yellow)
mSet_yellow[["name.map"]][["hit.values"]]
mSet_yellow<-SetMetabolomeFilter(mSet_yellow, F)

mSet_yellow_dataset <- mSet_yellow$dataSet #extracting input dataframe
mSet_yellow_KEGG <- as.data.frame(mSet_yellow_dataset$map.table) #extracting KEGG terms
write.csv(mSet_yellow_KEGG, "../../output/Metabolomics/MetaboAnalyst/mSet_yellow_KEGG.csv")

mSet_yellow<-SetCurrentMsetLib(mSet_yellow, "kegg_pathway", 2)
mSet_yellow<-CalculateHyperScore(mSet_yellow)
mSet_yellow_Path_KEGG <- mSet_yellow$api
mSet_yellow_ora <- as.data.frame(mSet_yellow_Path_KEGG$ora.results)
write.csv(mSet_yellow_ora, "../../output/Metabolomics/MetaboAnalyst/mSet_yellow_ora.csv")
```

Conduct enrichment analysis for Cluster 3 and save data frame with KEGG terms.  
```{r}
# Enrichment analysis for blue module

mSet_blue <-InitDataObjects("conc", "msetora", FALSE)
cmpd.vec.blue<-c(module_blue$Metabolite)
mSet_blue<-Setup.MapData(mSet_blue, cmpd.vec.blue)
mSet_blue<-CrossReferencing(mSet_blue, "name")
mSet_blue<-CreateMappingResultTable(mSet_blue)
mSet_blue<-GetCandidateList(mSet_blue)

mSet_blue<-PerformDetailMatch(mSet_blue, "N-acetyl-L-ornithine")
mSet_blue<-SetCandidate(mSet_blue, "N-acetyl-L-ornithine", "N-Acetylornithine")

mSet_blue<-PerformDetailMatch(mSet_blue, "NG-dimethyl-L-arginine")
mSet_blue<-SetCandidate(mSet_blue, "NG-dimethyl-L-arginine", "Asymmetric dimethylarginine")

# mSet_blue<-PerformDetailMatch(mSet_blue, "Xanthosine-5-phosphate")
# mSet_blue<-GetCandidateList(mSet_blue)
# mSet_blue<-SetCandidate(mSet_blue, "Xanthosine-5-phosphate", "Xanthylic acid") #not working for some reason

mSet_blue[["name.map"]][["hit.values"]]
mSet_blue<-SetMetabolomeFilter(mSet_blue, F)

mSet_blue_dataset <- mSet_blue$dataSet #extracting input dataframe
mSet_blue_KEGG <- as.data.frame(mSet_blue_dataset$map.table) #extracting KEGG terms
write.csv(mSet_blue_KEGG, "../../output/Metabolomics/MetaboAnalyst/mSet_blue_KEGG.csv") #Invesrigate KEGG matching further

mSet_blue<-SetCurrentMsetLib(mSet_blue, "kegg_pathway", 2)
mSet_blue<-CalculateHyperScore(mSet_blue)
mSet_blue_Path_KEGG <- mSet_blue$api
mSet_blue_ora <- as.data.frame(mSet_blue_Path_KEGG$ora.results)
write.csv(mSet_blue_ora, "../../output/Metabolomics/MetaboAnalyst/mSet_blue_ora.csv")
```




































## Co-expression adjacency and topological overlap matrix similarity  

Co-expression similarity and adjacency, using the soft thresholding power 7 and translate the adjacency into topological overlap matrix to calculate the corresponding dissimilarity. I will use a **signed network**: https://peterlangfelder.com/2018/11/25/__trashed/
```{r, }
# #Set up workspace
#getwd() #Display the current working directory
# #If necessary, change the path below to the directory where the data files are stored. "." means current directory. On Windows use a forward slash / instead of the usual \.
#workingDir = ".";
# setwd(WGCNA_dev);
# library(WGCNA) #Load the WGCNA package
options(stringsAsFactors = FALSE) #The following setting is important, do not omit.
enableWGCNAThreads() #Allow multi-threading within WGCNA. 
# 
# #Load the data saved in the first part
adjTOM <- data_filt
adjTOM
# 
# #Run analysis
softPower=7 #Set softPower
adjacency=adjacency(data_filt, power=softPower, type="unsigned") #Calculate adjacency

TOM= TOMsimilarity(adjacency,TOMType = "unsigned") #Translate adjacency into topological overlap matrix
#this step can take awhile 

dissTOM= 1-TOM #Calculate dissimilarity in TOM

save(adjacency, TOM, dissTOM, file = "Mcap2020/Output/Metabolomics/adjTOM.RData") #Save 

save(dissTOM, file = "Mcap2020/Output/Metabolomics/dissTOM.RData") #Save 
```

Load in dissTOM file obtained from previous R chunk.    
```{r}
dissTOM_in <- load(file="Mcap2020/Output/Metabolomics/dissTOM.RData") 
dissTOM_in
```

## Clustering using TOM

Form distance matrix
```{r}
geneTree=flashClust(as.dist(dissTOM), method="average")
```

We will now plot a dendrogram of metabolites Each leaf corresponds to a metabolite, branches grouping together densely are interconnected, highly co-expressed metabolites.  
```{r}
pdf(file="Mcap2020/Figures/Metabolomics/WGCNA/dissTOMClustering.pdf", width=10, height=10)
plot(geneTree, xlab="", sub="", main= "Gene Clustering on TOM-based dissimilarity", labels= FALSE,hang=0.04)
dev.off()
```

## Module identification using dynamicTreeCut  

Module identification is essentially cutting the branches off the tree in the dendrogram above. We like large modules, so we set the **minimum module size** relatively high, so we will set the minimum size at 5. 5 chosen for now to try out, but return to this for metabolomics specific numbers.  

```{r}
minModuleSize = 5
dynamicMods = cutreeDynamic(dendro = geneTree, distM = dissTOM,
deepSplit = 2, pamRespectsDendro = FALSE,
minClusterSize = minModuleSize)
table(dynamicMods) #list modules and respective sizes
save(dynamicMods, geneTree, file = "Mcap2020/Output/Metabolomics/dyMod_geneTree.RData") #Save to load into RStudio
```
Module 0 is reserved for unassigned metabolites. The are other modules will be listed largest to smallest.

Load modules calculated from the adjacency matrix.  
```{r}
dyMod_geneTree <- load(file = "Mcap2020/Output/Metabolomics/dyMod_geneTree.RData")
dyMod_geneTree
```

Plot the module assignment under the gene dendrogram
```{r}
#dynamicColors = labels2colors(dynamicMods) # Convert numeric labels into colors
dynamicColors=dynamicMods
table(dynamicColors)

pdf(file="Mcap2020/Figures/Metabolomics/WGCNA/dissTOMColorClustering.pdf", width=20, height=20)
plotDendroAndColors(geneTree, dynamicColors, "Dynamic Tree Cut", dendroLabels = FALSE, hang = 0.03, addGuide = TRUE, guideHang = 0.05, main = "Gene dendrogram and module colors")
dev.off()
```

**Merge modules with >85% eigengene similarity.** Most studies use somewhere between 80-90% similarity. It looks like most of our modules are highly related so I will use 90% similarity as my merging threshold.



METree doesn't exist before this point? 
```{r}
MEDissThres= 0.15 #merge modules that are 85% similar

pdf(file="Mcap2020/Figures/Metabolomics/WGCNA/eigengeneClustering2.pdf", width = 20)
plot(METree, main = "Clustering of module eigengenes", xlab = "", sub = "")
abline(h=MEDissThres, col="red")
dev.off()

merge= mergeCloseModules(data_filt, dynamicColors, cutHeight= MEDissThres, verbose =3)

mergedColors= merge$colors
mergedMEs= merge$newMEs

pdf(file="Mcap2020/Figures/Metabolomics/WGCNA/mergedClusters.pdf", width=20, height=20)
plotDendroAndColors(geneTree, cbind(dynamicColors, mergedColors), c("Dynamic Tree Cut", "Merged dynamic"), dendroLabels= FALSE, hang=0.03, addGuide= TRUE, guideHang=0.05)
dev.off()
```

Save new colors
```{r}
moduleLabels=mergedColors
moduleColors = mergedColors # Rename to moduleColors
#colorOrder = c("grey", standardColors(50)); # Construct numerical labels corresponding to the colors
#moduleLabels = match(moduleColors, colorOrder)-1;
MEs = mergedMEs;
ncol(MEs) #How many modules do we have now?
```

We have 10 modules after merging with 85% similarity.   

Plot new tree with 10 modules.  
```{r}
#Calculate dissimilarity of module eigengenes
MEDiss = 1-cor(MEs)
#Cluster again and plot the results
pdf(file="Mcap2020/Figures/Metabolomics/WGCNA/eigengeneClustering3.pdf")
METree = flashClust(as.dist(MEDiss), method = "average")
MEtreePlot = plot(METree, main = "Clustering of module eigengenes", xlab = "", sub = "")
dev.off()
```
















# Correlate to developmental stages  

Prepare trait data. Data has to be numeric, so I will substitute time points/developmental stages for numeric values. The "trait" we are considering here is lifestage  

Make a dataframe that has a column for each lifestage name and a row for samples. Populate a 1 for samples that match each lifestage and a 0 for samples not matching respective lifestages. 

This process changes lifestages from a categorical variable into a binary variable. This will allow for correlations between mean eigengenes and lifestage.  
 
```{r}
metadata$num <- c("1")
allTraits <- as.data.frame(pivot_wider(metadata, names_from = Lifestage, values_from = num, id_cols = Sample))
allTraits[is.na(allTraits)] <- c("0")
rownames(allTraits) <- allTraits$Sample
datTraits <- allTraits[,c(-1)]
head(datTraits)
```

Define numbers of genes and samples and print.  
```{r}
nMetabolites = ncol(data_filt)
nSamples = nrow(data_filt)

nMetabolites
nSamples
```

We have 181 metabolites and 47 samples.  

Generate labels for module eigengenes as numbers.  
```{r}
MEs0 = moduleEigengenes(data_filt, moduleLabels,softPower=7)$eigengenes
MEs = orderMEs(MEs0)
names(MEs)
```

Correlations of traits with eigengenes
```{r}
moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);
Colors=sub("ME","", names(MEs))

moduleTraitTree = hclust(dist(t(moduleTraitCor)), method = "average")

pdf(file="Mcap2020/Figures/Metabolomics/WGCNA/ModuleTraitClusterTree.pdf", height=8, width=22)
plot(moduleTraitTree)
dev.off()
```

Correlations of metabolites with eigengenes. Calculate correlations between ME's and lifestages. 
```{r}
moduleGeneCor=cor(MEs,data_filt)
moduleGenePvalue = corPvalueStudent(moduleGeneCor, nSamples);
head(moduleGenePvalue)
```

Calculate kME values (module membership). 

```{r}
datKME = signedKME(data_filt, MEs, outputColumnName = "kME")
head(datKME)
```

Save module colors and labels for use in subsequent analyses.  

```{r}
save(MEs, moduleLabels, moduleColors, geneTree, file = "Mcap2020/Output/Metabolomics/NetworkConstructionWGCNA.RData") 
```

## Plot module-trait associations

Represent module trait correlations as a heatmap 
```{r}
textMatrix = paste(signif(moduleTraitCor, 2), "\n(",signif(moduleTraitPvalue, 1), ")", sep = "")
dim(textMatrix) = dim(moduleTraitCor)
head(textMatrix)

labeledHeatmap(Matrix = moduleTraitCor, xLabels = names(datTraits),  yLabels = names(MEs), ySymbols = names(MEs), cex.lab.y= 0.55, cex.lab.x= 0.55, colors = blueWhiteRed(50), textMatrix = textMatrix, setStdMargins = TRUE, cex.text = 0.25, textAdj = , zlim = c(-1,1), main = paste("Module-trait relationships"))

pdf(file="Mcap2020/Figures/Metabolomics/WGCNA/Module-trait-relationships.pdf")
labeledHeatmap(Matrix = moduleTraitCor, xLabels = names(datTraits),  yLabels = names(MEs), ySymbols = names(MEs), cex.lab.y= 0.55, cex.lab.x= 0.55, colors = blueWhiteRed(50), textMatrix = textMatrix, setStdMargins = TRUE, cex.text = 0.25, textAdj = , zlim = c(-1,1), main = paste("Module-trait relationships"))
dev.off()
```

Generate a complex heatmap of module-trait relationships.  

```{r}
#bold sig p-values
#dendrogram with WGCNA MEtree cut-off
#colored y-axis

#Create list of pvalues for eigengene correlation with specific life stages
heatmappval <- signif(moduleTraitPvalue, 1)

#Make list of heatmap row colors
htmap.colors <- names(MEs)
htmap.colors <- gsub("ME", "", htmap.colors)

#lifestage_order<-c("1_Egg", "2_Embryo", "3_Larvae1", "4_Larvae2", "5_Larvae3", "6_Larvae4", "7_Larvae6", "8_MetamorposedRecruit2", "9_CalcifyingRecruit1", "10_CalcifyingRecruit2")

library(dendsort)
row_dend = dendsort(hclust(dist(moduleTraitCor)))
col_dend = dendsort(hclust(dist(t(moduleTraitCor))))

pdf(file = "Mcap2020/Figures/Metabolomics/WGCNA/Module-trait-relationship-heatmap.pdf", height = 8, width = 8)
ht=Heatmap(moduleTraitCor, name = "Eigengene", column_title = "Module-Lifestage Eigengene Correlation", 
        col = blueWhiteRed(50), 
        row_names_side = "left", 
        row_dend_side = "left",
        width = unit(5, "in"), 
        height = unit(4.5, "in"), 
        column_dend_reorder = TRUE, 
        #cluster_columns = hclust(dist(t(moduleTraitCor)), method = "average"),
        cluster_columns = col_dend,
        row_dend_reorder = FALSE,
        column_split = 6, 
        column_dend_height = unit(.5, "in"),
        #cluster_rows = METree, 
        cluster_rows = row_dend, 
        row_gap = unit(2.5, "mm"), 
        border = TRUE,
        cell_fun = function(j, i, x, y, w, h, col) {
        if(heatmappval[i, j] < 0.05) {
            grid.text(sprintf("%s", heatmappval[i, j]), x, y, gp = gpar(fontsize = 10, fontface = "bold"))
        }
        else {
            grid.text(sprintf("%s", heatmappval[i, j]), x, y, gp = gpar(fontsize = 10, fontface = "plain"))
        }},
        column_names_gp =  gpar(fontsize = 12, border=FALSE),
        row_names_gp = gpar(fontsize = 12, alpha = 0.75, border = FALSE))
draw(ht)
dev.off()

```

# **Plot mean eigengene over developmental stages**  

View module eigengene data and make dataframe for Strader plots.  
```{r}
head(MEs)
names(MEs)
Strader_MEs <- MEs
Strader_MEs$Lifestage <- metadata$Lifestage
Strader_MEs$sample_id <- rownames(Strader_MEs)
head(Strader_MEs)

Strader_MEs<-Strader_MEs%>%
  droplevels() #drop unused level

dim(Strader_MEs)
head(Strader_MEs)

time_point_order = c("Egg", "Embryo", "Larvae1", "Larvae2", "Larvae3", "Larvae4", "Larvae5", "Larvae6", "Recruit1", "Recruit2", "Recruit1plug", "Recruit2plug", "Recruit3plug") #Set time_point order
```


Plot mean module eigengene for each module.  

```{r}
#convert wide format to long format for plotting  
plot_MEs<-Strader_MEs%>%
  gather(., key="Module", value="Mean", 1:10)

dev.off() 

expression_plots<-plot_MEs%>%
  group_by(Module, Lifestage) %>%
  ggplot(aes(x=Lifestage, y=Mean, group=Lifestage)) +
  facet_grid(~Module)+
  geom_jitter(alpha = 0.5) +
  geom_boxplot(alpha=0) +
  scale_x_discrete(limits=time_point_order) +
  #ylim(-0.5,1) +
  ylab("Mean Module Eigenegene") +
  geom_hline(yintercept = 0, linetype="dashed", color = "grey")+
  theme_bw() + 
  theme(axis.text.x=element_text(angle = 90, vjust = 0.5, hjust=1, size = 12), #set x-axis label size
        axis.title.x=element_text(size = 14), #set x-axis title size
        axis.ticks.x=element_blank(), #No x-label ticks
        #axis.title.y=element_blank(), #No y-axis title
        axis.text.y=element_text(size = 14), #set y-axis label size, 
        panel.border = element_rect(color = "black", fill = NA, size = 1), #set border
        panel.grid.major = element_blank(), #Set major gridlines
        panel.grid.minor = element_blank(), #Set minor gridlines
        axis.line = element_line(colour = "black"), #Set axes color
        plot.background=element_blank(),
        plot.title = element_text(size=22)); expression_plots

ggsave(expression_plots, file="Mcap2020/Figures/Metabolomics/WGCNA/expression_eigengene.pdf", height=6, width=20)
```


# Calculating gene significance and module membership    

We quantify associations of individual genes with life stage by defining Gene Significance GS as the absolute value of the correlation between the metabolite and the lifestage timepoint. For each module, we also define a quantitative measure of module membership (MM) as the correlation of the module eigengene and the gene expression profile.  

Define lifestage as a numeric value (ranging from 1 (egg, first timepoint)-10 (recruit, last time point)).  

```{r}
expressionProfile_data <- Strader_MEs

expressionProfile_data<-expressionProfile_data%>%
  droplevels() #drop unused level

cols.num <- c(1:10)

expressionProfile_data[cols.num] <- sapply(expressionProfile_data[cols.num],as.numeric)
sapply(expressionProfile_data, class)

dim(expressionProfile_data)
head(expressionProfile_data)

lifestage <- as.data.frame(expressionProfile_data$Lifestage)
names(lifestage) = "lifestage"

lifestage<-lifestage%>%
  mutate(lifestage_num=if_else(lifestage == "Egg", "1", 
                               if_else(lifestage =="Embryo", "2",
                                       if_else(lifestage == "Larvae1", "3", 
                                               if_else(lifestage=="Larvae2", "4", 
                                                       if_else(lifestage=="Larvae3", "5",
                                                               if_else(lifestage=="Larvae4", "6",
                                                                      if_else(lifestage=="Larvae5", "7",
                                                                              if_else(lifestage=="Larvae6", "8",
                                                                                   if_else(lifestage=="Recruit1", "9",
                                                                                              if_else(lifestage=="Recruit2", "10",
                                                                                                        if_else(lifestage=="Recruit1plug", "11",
                                                                                                              if_else(lifestage=="Recruit2plug", "12",
                                                                                                                  if_else(lifestage=="Recruit3plug", "13","NA"))))))))))))))

lifestage$lifestage_num<-as.numeric(lifestage$lifestage_num)
lifestage<-lifestage%>%
  select(lifestage_num)

dim(lifestage)
```

Generate data frame for module membership for each gene (absolute value of correlation between module eigengene and gene).  
- geneModuleMembership = correlation of the module eigengene and the gene 
- MMPvalue = p-value of correlation between module eigengene and the gene 
```{r}
modNames = substring(names(MEs), 3) #pull out module names

geneModuleMembership = as.data.frame(cor(data_filt, MEs, use = "p"));
MMPvalue = as.data.frame(corPvalueStudent(as.matrix(geneModuleMembership), nSamples));

names(geneModuleMembership) = paste("MM", modNames, sep="");
names(MMPvalue) = paste("p.MM", modNames, sep="");
```

Generate dataframe with Gene Significance GS as the absolute value of the correlation between the metabolite and the lifestage timepoint 
- geneTraitSignificance = correlation of the gene and lifestage time point 
- GSPvalue = p-value of correlation between gene and lifestage time point  
```{r}
geneTraitSignificance = as.data.frame(cor(data_filt, lifestage, use = "p"));
GSPvalue = as.data.frame(corPvalueStudent(as.matrix(geneTraitSignificance), nSamples));

names(geneTraitSignificance) = paste("GS.", names(lifestage), sep="");
names(GSPvalue) = paste("p.GS.", names(lifestage), sep="");
```

AH WORKING HERE 

Data frame for significance with module: moduleGenePvalue; datKME


