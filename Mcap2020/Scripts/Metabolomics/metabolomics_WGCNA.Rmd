---
title: Montipora capitata 2020 metabolomics WGCNA analysis
author: "AS Huffmyer"
date: '2023'
output:
  html_document:
    code_folding: hide
    toc: yes
    toc_depth: 6
    toc_float: yes
  pdf_document:
    keep_tex: yes
editor_options: 
  chunk_output_type: console
---

Set up workspace, set options, and load required packages.    
```{r}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)

options(stringsAsFactors = FALSE) #Set Strings to character
```

```{r, warning=FALSE, message=FALSE}
## install packages if you dont already have them in your library
if ("tidyverse" %in% rownames(installed.packages()) == 'FALSE') install.packages('tidyverse') 
if ("vegan" %in% rownames(installed.packages()) == 'FALSE') install.packages('vegan') 
if ("ggplot2" %in% rownames(installed.packages()) == 'FALSE') install.packages('ggplot2') 
if ("factoextra" %in% rownames(installed.packages()) == 'FALSE') install.packages('factoextra') 
if ("ggfortify" %in% rownames(installed.packages()) == 'FALSE') install.packages('ggfortify') 
if ("naniar" %in% rownames(installed.packages()) == 'FALSE') install.packages('naniar') 
if ("cowplot" %in% rownames(installed.packages()) == 'FALSE') install.packages('cowplot') 
if (!requireNamespace("BiocManager", quietly = TRUE))
    install.packages("BiocManager")
if ("mixOmics" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install("mixOmics") 
if ("RVAideMemoire" %in% rownames(installed.packages()) == 'FALSE') install.packages('RVAideMemoire') 
if ("VennDiagram" %in% rownames(installed.packages()) == 'FALSE') install.packages('VennDiagram') 
if ("broom" %in% rownames(installed.packages()) == 'FALSE') install.packages('broom') 
if ("devtools" %in% rownames(installed.packages()) == 'FALSE') install.packages('devtools') 

#load packages
library("ggplot2")
library('vegan')
library('factoextra')
library('ggfortify')
library('naniar')
library('cowplot')
library("mixOmics")
library("tidyverse")
library("RVAideMemoire")
library("VennDiagram")
library("broom")
library("devtools")

if ("genefilter" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install("genefilter") 
if ("DESeq2" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('DESeq2') 
if ("RColorBrewer" %in% rownames(installed.packages()) == 'FALSE') install.packages('RColorBrewer') 
if ("WGCNA" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('WGCNA') 
if ("flashClust" %in% rownames(installed.packages()) == 'FALSE') install.packages('flashClust') 
if ("gridExtra" %in% rownames(installed.packages()) == 'FALSE') install.packages('gridExtra') 
if ("ComplexHeatmap" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('ComplexHeatmap') 
if ("goseq" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('goseq') 
if ("dplyr" %in% rownames(installed.packages()) == 'FALSE') install.packages('dplyr') 
if ("clusterProfiler" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('clusterProfiler') 
if ("pheatmap" %in% rownames(installed.packages()) == 'FALSE') install.packages('pheatmap') 
if ("magrittr" %in% rownames(installed.packages()) == 'FALSE') install.packages('magrittr') 
if ("dendsort" %in% rownames(installed.packages()) == 'FALSE') BiocManager::install('dendsort') 

library("genefilter")
library("DESeq2")
library("RColorBrewer")
library("WGCNA")
library("flashClust")
library("gridExtra")
library("ComplexHeatmap")
library("goseq")
library("dplyr")
library("clusterProfiler")
library("pheatmap")
library("magrittr")
library("dendsort")
```

This script uses WGCNA analysis on metabolomics data set to explore whether we can detect "modules" of genes that are correlated with lifestage. PLS-DA analyses and multivariate analyses are conducted in metabolomics.Rmd script. This pipeline modified from scripts from Kevin Wong.  

# Pipeline Overview

1. Data preparation
  + Load and format clean data
  + Data filtering: PoverA and genefilter
  + Outlier detection
2. Network construction and consensus module detection
  + Choosing a soft-thresholding power: Analysis of a network topology β  
  + Identify modules using blockwiseModules  
  + Relate modules to sample information  
  + Relate modules to life stage
3. Plot module-trait associations
4. Plot mean eigengene values for each module  
5. Pathway analysis    

# 1. Data Preparation  

## Load and format clean data  

Read in data file and create metadata with sample information as well as a count matrix with metabolite counts. Data will be read in from "selected metabolites" dataset that has already undergone polarity selection, cleaning metabolite names, and median-centered normalized ion counts in the metabolomics.Rmd script.  

```{r}
data<-read.csv("Mcap2020/Output/Metabolomics/selected_metabolites.csv")

metadata<-data%>%
  dplyr::select(Lifestage, Rep, HPF, Development)%>%
  mutate(Sample=paste(Lifestage, Rep, sep="-"))

metadata<-metadata[1:47,] #reduce to just one set of metadata 

data<-data%>%
  mutate(Sample=paste(Lifestage, Rep, sep="-"))%>%
  dplyr::select(Sample, compound, norm_counts)
```

Convert the data table to a wide format with samples in columns and metabolites in rows.  

```{r}
data<-data%>%
  spread(Sample, norm_counts)

head(data)

rownames(data)<-data$compound

data<-data%>%
  dplyr::select(-compound)
```

Check that there are no metabolites with 0 counts for all samples. Should return TRUE.  

```{r}
rowSums(dplyr::count(data)) > 0
```

## Data filtering: PoverA and genefilter  

Conduct data filtering, this includes:  

*pOverA*: Specifying the minimum count for a proportion of samples for each metabolite. Here, we are using a pOverA of 0.07. This is because we have 46 samples with a minimum of n=2 samples per lifestage. Therefore, we will accept genes that are present in 2/46 = 0.04 of the samples because we expect different metabolites by life stage as demonstrated by PLSDA analysis (as analyzed in metabolomics.Rmd). We are further setting the minimum value of metabolites to 0.01 (median normalized), such that 4% of the samples must have a non-zero normalized metabolite presence in order for the metabolite to remain in the data set.  

Filter in the package "genefilter". Pre-filtering our dataset to reduce the memory size dataframe, increase the speed of the transformation and testing functions, and improve quality of statistical analysis by removing low-coverage counts. Removed counts could represent outliers in the data and removing these improves sensitivity of statistical tests.   

```{r}
filt <- filterfun(pOverA(0.04,0.01))

#create filter for the counts data
gfilt <- genefilter(data, filt)

#identify genes to keep by count filter
keep <- data[gfilt,]

#identify gene lists
n.keep <- rownames(keep)

#gene count data filtered in PoverA, P percent of the samples have counts over A
data_filt <- as.data.frame(data[which(rownames(data) %in% n.keep),])

#How many rows do we have before and after filtering?
nrow(data) #Before
nrow(data_filt) #After
```

Filtering does not remove any metabolites, all 182 metabolites are used in analysis.  

Check that all row and column names match. Should return TRUE.  
```{r}
#Checking that all row and column names match. Should return "TRUE"
all(rownames(metadata$sample_id) %in% colnames(data_filt))
all(rownames(metadata$sample_id) == colnames(data_filt)) 
```

## Outlier detection  

Look for outliers by examining tree of metabolites  
```{r}
sampleTree = hclust(dist(data_filt), method = "average");
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
# The user should change the dimensions if the window is too large or too small.
pdf("Mcap2020/Figures/Metabolomics/WGCNA/outliers_metabolites.pdf")
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)
dev.off()
```

Betaine could be a large outlier, likely due to very high abundance compared to other metabolites. I tried analysis with and without Betaine. Proceeding now without removing Betaine because there are no sample outliers with including betaine in analysis.      

```{r}
outlier<-c("Betaine")
#data_filt<-data_filt%>%
  #filter(!row.names(data_filt) %in% outlier)
```

Now look at the tree again.   
```{r}
sampleTree = hclust(dist(data_filt), method = "average");
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
# The user should change the dimensions if the window is too large or too small.
pdf("Mcap2020/Figures/Metabolomics/WGCNA/outliers_metabolites_filt.pdf")
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)
dev.off()
```

Transpose such that samples are in rows and metabolites are in columns.  

```{r}
data_filt <- t(data_filt) 
```

Look for outlier samples by examining tree of samples  
```{r}
sampleTree = hclust(dist(data_filt), method = "average");
# Plot the sample tree: Open a graphic output window of size 12 by 9 inches
# The user should change the dimensions if the window is too large or too small.
pdf("Mcap2020/Figures/Metabolomics/WGCNA/outliers_samples.pdf")
plot(sampleTree, main = "Sample clustering to detect outliers", sub="", xlab="", cex.lab = 1.5, cex.axis = 1.5, cex.main = 2)
dev.off()
```

No clear outliers for samples.   

# 2. Network construction and consensus module detection  

## Choosing a soft-thresholding power: Analysis of network topology β  

The soft thresholding power (β) is the number to which the co-expression similarity is raised to calculate adjacency. The function pickSoftThreshold performs a network topology analysis. The user chooses a set of candidate powers, however the default parameters are suitable values.  
```{r, message=FALSE, warning=FALSE}
# # Choose a set of soft-thresholding powers
allowWGCNAThreads()

powers <- c(c(1:20), seq(from = 12, to=20, by=2)) #Create a string of numbers from 1 through 10, and even numbers from 10 through 20
# 
# # Call the network topology analysis function
sft <-pickSoftThreshold(data_filt, powerVector = powers, verbose = 5)
```

Plot the results.  
```{r}
sizeGrWindow(9, 5)
par(mfrow = c(1,2));
cex1 = 0.9;
# # # Scale-free topology fit index as a function of the soft-thresholding power
plot(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
      xlab="Soft Threshold (power)",ylab="Scale Free Topology Model Fit,signed R^2",type="n",
     main = paste("Scale independence"));
 text(sft$fitIndices[,1], -sign(sft$fitIndices[,3])*sft$fitIndices[,2],
     labels=powers,cex=cex1,col="red");
# # # this line corresponds to using an R^2 cut-off
 abline(h=0.8,col="red")
# # # Mean connectivity as a function of the soft-thresholding power
 plot(sft$fitIndices[,1], sft$fitIndices[,5],
     xlab="Soft Threshold (power)",ylab="Mean Connectivity", type="n",
     main = paste("Mean connectivity"))
 text(sft$fitIndices[,1], sft$fitIndices[,5], labels=powers, cex=cex1,col="red")
```

From this data, it appears that our **soft thresholding power is 7**.  

## Identify modules using blockwiseModules  

Use blockwiseModules to identify modules of metabolites.  

Settings used: 

networkType = "unsigned" 
deepSplit = 2
pamRespectsDendro = F
minModuleSize = 5
maxBlockSize = 4000
reassignThreshold = 0
mergeCutHeight = 0.25

Need to change RData output 

``` {r, echo=TRUE, warning=FALSE, message=FALSE}

picked_power = 7
temp_cor <- cor       
cor <- WGCNA::cor                                             # Force it to use WGCNA cor function (fix a namespace conflict issue)
netwk <- blockwiseModules(data_filt,                         # <= input here

                          # == Adjacency Function ==
                          power = picked_power,               # <= power here
                          networkType = "unsigned",

                          # == Tree and Block Options ==
                          deepSplit = 2,
                          pamRespectsDendro = F,
                          # detectCutHeight = 0.75,
                          minModuleSize = 5,                  
                          maxBlockSize = 4000,

                          # == Module Adjustments ==
                          reassignThreshold = 0,
                          mergeCutHeight = 0.25,

                          # == TOM == Archive the run results in TOM file (saves time) but it doesn't save a file
                          saveTOMs = F,
                          saveTOMFileBase = "ER",

                          # == Output Options
                          numericLabels = T,
                          verbose = 3)

cor <- temp_cor     # Return cor function to original namespace

# Identify labels as numbers 
mergedColors = netwk$colors
# Plot the dendrogram and the module colors underneath

pdf("Mcap2020/Figures/Metabolomics/WGCNA/blockwise_module_colors.pdf")
plotDendroAndColors(
  netwk$dendrograms[[1]],
  mergedColors[netwk$blockGenes[[1]]],
  "Module colors",
  dendroLabels = FALSE,
  hang = 0.03,
  addGuide = TRUE,
  guideHang = 0.05 )
dev.off()

table(mergedColors)
```

Module sizes are as follows: 
mergedColors
 0  1  2  3  4  5  6  7  8 
14 66 29 27 17 10  8  6  5 

## Relate modules to sample information  

``` {r, echo=TRUE, warning=FALSE, message=FALSE}
module_df <- data.frame(
  Metabolite = names(netwk$colors),
  colors = netwk$colors
  #colors = labels2colors(netwk$colors)
)

module_df[1:5,]

write.csv(module_df, "Mcap2020/Output/Metabolomics/WGCNA/metabolite_modules.csv")

# Get Module Eigengenes per cluster
MEs <- moduleEigengenes(data_filt, mergedColors)$eigengenes

# Reorder modules so similar modules are next to each other
MEs <- orderMEs(MEs)
module_order = names(MEs) %>% gsub("ME","", .)

# Add Sample names
MEs0 <- MEs
MEs0$Sample.ID = row.names(MEs)

# tidy & plot data
mME = MEs0 %>%
  pivot_longer(-Sample.ID) %>%
  mutate(
    name = gsub("ME", "", name),
    name = factor(name, levels = module_order)
  )

mME %>% ggplot(., aes(x=Sample.ID, y=name, fill=value)) +
  geom_tile() +
  theme_bw() +
  scale_fill_gradient2(
    low = "blue",
    high = "red",
    mid = "white",
    midpoint = 0,
    limit = c(-1,1)) +
  theme(axis.text.x = element_text(angle=90)) +
  labs(title = "Module-Sample Relationships", y = "Modules", fill="corr")
```


## Relate modules to life stage  

Prepare trait data. Data has to be numeric, so I will substitute time points/developmental stages for numeric values. The "trait" we are considering here is lifestage. Make a dataframe that has a column for each lifestage name and a row for samples. Populate a 1 for samples that match each lifestage and a 0 for samples not matching respective lifestages. This process changes lifestages from a categorical variable into a binary variable. This will allow for correlations between mean eigengenes and lifestage.  
 
```{r}
metadata$num <- c("1")
allTraits <- as.data.frame(pivot_wider(metadata, names_from = HPF, values_from = num, id_cols = Sample))
allTraits[is.na(allTraits)] <- c("0")
rownames(allTraits) <- allTraits$Sample
datTraits <- allTraits[,c(-1)]
head(datTraits)

#define numbers of metabolites and samples and view 
nMetabolites = ncol(data_filt)
nSamples = nrow(data_filt)

nMetabolites
nSamples
```

We have 182 metabolites and 47 samples.   

Next correlate the trait of life stage with eigengenes (modules).  

```{r}
# Correlations of traits with eigengenes
moduleTraitCor = cor(MEs, datTraits, use = "p");
moduleTraitPvalue = corPvalueStudent(moduleTraitCor, nSamples);
Colors=sub("ME","", names(MEs))
moduleTraitTree = hclust(dist(t(moduleTraitCor)), method = "average")
pdf(file="Mcap2020/Figures/Metabolomics/WGCNA/ModuleTraitClusterTree.pdf", height=8, width=22)
plot(moduleTraitTree)
dev.off()

# Correlations of metabolites with eigengenes. Calculate correlations between ME's and groups 
moduleGeneCor=cor(MEs,data_filt)
moduleGenePvalue = corPvalueStudent(moduleGeneCor, nSamples);
head(moduleGenePvalue)
```

## Plot module-trait associations

Represent module trait correlations as a heatmap.  
```{r, echo=TRUE, warning=FALSE, message=FALSE}
textMatrix = paste(signif(moduleTraitCor, 2), "\n(",signif(moduleTraitPvalue, 1), ")", sep = "")
dim(textMatrix) = dim(moduleTraitCor)
head(textMatrix)
labeledHeatmap(Matrix = moduleTraitCor, xLabels = names(datTraits),  yLabels = names(MEs), ySymbols = names(MEs), cex.lab.y= 0.55, cex.lab.x= 0.55, colors = blueWhiteRed(50), textMatrix = textMatrix, setStdMargins = TRUE, cex.text = 0.25, textAdj = , zlim = c(-1,1), main = paste("Module-trait relationships"))
pdf(file="Mcap2020/Figures/Metabolomics/WGCNA/Module-trait-relationships.pdf")
labeledHeatmap(Matrix = moduleTraitCor, xLabels = names(datTraits),  yLabels = names(MEs), ySymbols = names(MEs), cex.lab.y= 0.55, cex.lab.x= 0.55, colors = blueWhiteRed(50), textMatrix = textMatrix, setStdMargins = TRUE, cex.text = 0.25, textAdj = , zlim = c(-1,1), main = paste("Module-trait relationships"))
dev.off()

```

# 3. Plot module trait associations with a complex heatmap   

```{r, echo=TRUE, warning=FALSE, message=FALSE}
#bold sig p-values
#dendrogram with WGCNA MEtree cut-off
#colored y-axis
#Create list of pvalues for eigengene correlation with specific life stages
heatmappval <- signif(moduleTraitPvalue, 1)
#Make list of heatmap row colors
htmap.colors <- names(MEs)
htmap.colors <- gsub("ME", "", htmap.colors)

row_dend = dendsort(hclust(dist(moduleTraitCor)))
col_dend = dendsort(hclust(dist(t(moduleTraitCor))))

#row_ha = rowAnnotation(ModuleSize = anno_text("11", "127", "8", "64", "85"), just = "left", 
#        location = unit(0.5, "npc"), show_name = TRUE)
# brown (11), grey (127), yellow (8), blue (64), turqoise (85) #figure out how to do row annotations to add sample sizes

lifestage_order<-c("Egg (1 hpf)", "Embryo (5 hpf)", "Embryo (38 hpf)", "Embryo (65 hpf)", "Larvae (93 hpf)", "Larvae (163 hpf)", "Larvae (183 hpf)", "Larvae (231 hpf)", "Metamorphosed Polyp (183 hpf)", "Metamorphosed Polyp (231 hpf)", "Attached Recruit (183 hpf)", "Attached Recruit (231 hpf)", "Attached Recruit (255 hpf)")

pdf(file = "Mcap2020/Figures/Metabolomics/WGCNA/Module-trait-relationship-heatmap.pdf", height = 8, width = 8)
ht=Heatmap(moduleTraitCor, name = "Eigengene", column_title = "Module-Group Eigengene Correlation", 
        col = blueWhiteRed(50), 
        row_names_side = "left", 
        row_dend_side = "left",
        width = unit(5, "in"), 
        height = unit(4.5, "in"), 
        #column_dend_reorder = TRUE, 
        #cluster_columns = col_dend,
        row_dend_reorder = FALSE,
        #column_split = 4, 
        row_split = 3, 
        #column_dend_height = unit(.5, "in"),
        cluster_rows = row_dend, 
        column_order = lifestage_order, 
        row_gap = unit(2.5, "mm"), 
        border = TRUE,
        cell_fun = function(j, i, x, y, w, h, col) {
        if(heatmappval[i, j] < 0.05) {
            grid.text(sprintf("%s", heatmappval[i, j]), x, y, gp = gpar(fontsize = 10, fontface = "bold"))
        }
        else {
            grid.text(sprintf("%s", heatmappval[i, j]), x, y, gp = gpar(fontsize = 10, fontface = "plain"))
        }},
        column_names_rot = 45,
        column_names_gp =  gpar(fontsize = 12, border=FALSE),
        row_names_gp = gpar(fontsize = 12, alpha = 0.75, border = FALSE))
draw(ht)
dev.off()
```

# 4. Plot mean eigengene values for each module

Load metadata and plot expression plots.  
```{r, echo=TRUE, warning=FALSE, message=FALSE}

# Number of each metabolites in each module 
row_mod_num <- data.frame(table(module_df$colors)) 

# Bring in additional metadata

sample_metadata <- read.csv("Mcap2020/Data/Metabolomics/metabolomics_meta_wgcna.csv") 

sample_metadata$Sample.ID <- as.factor(sample_metadata$Sample.ID)
sample_metadata$lifestage <- as.factor(sample_metadata$lifestage)
sample_metadata$hpf <- as.factor(sample_metadata$hpf)
sample_metadata$group <- as.factor(sample_metadata$group)

mME_meta <- merge(mME, sample_metadata, by = "Sample.ID") %>%
  rename(Module = name)
```

Add module "cluster" categories determined by WGCNA above.  
```{r}
mME_meta<-mME_meta%>%
  mutate(Cluster=if_else(Module == "2", "Cluster1", 
                               if_else(Module =="5", "Cluster1", 
                                       if_else(Module == "0", "Cluster1", 
                                               if_else(Module == "7", "Cluster2",
                                               if_else(Module=="6", "Cluster2", 
                                                       if_else(Module == "3", "Cluster2", 
                                                       if_else(Module == "1", "Cluster3", 
                                                               if_else(Module == "8", "Cluster3",
                                                               if_else(Module == "4", "Cluster3", "NA"))))))))))

mME_meta$Cluster<-as.factor(mME_meta$Cluster)
```


Plot by time point with individual modules.  
```{r}

mME_meta$group <- factor(mME_meta$group, levels = c("Egg", "Embryo", "Larvae", "Metamorphosed Polyp", "Attached Recruit"))
mME_meta$Module <- factor(mME_meta$Module, levels = c("0", "1", "2", "3", "4", "5", "6", "7", "8"))

expression_plots<-mME_meta%>%
#  group_by(Module) %>%
  ggplot(aes(x=hpf, y=value, fill=group)) +
  facet_wrap(~ Module)+
  ylab("Mean Module Eigenegene Value") +
  geom_hline(yintercept = 0, linetype="dashed", color = "grey")+
  geom_boxplot(width=.5, outlier.shape= NA, position = position_dodge(width = 0.5), alpha = 0.7) +
  stat_summary(fun=mean, geom="line", aes(group=lifestage, color = group), position = position_dodge(width = 0.5))  + 
  geom_point(pch = 21, position = position_dodge(width = 0.5)) +
  scale_fill_manual(name="Lifestage", values=c("#8C510A", "#DFC27D","#80CDC1", "#003C30", "#BA55D3")) +
  scale_color_manual(name="Lifestage", values=c("#8C510A", "#DFC27D","#80CDC1", "#003C30", "#BA55D3")) + 
  xlab("Hours Post-Fertilization") + #Axis titles
  theme_bw() + theme(panel.border = element_rect(color="black", fill=NA, size=0.75), panel.grid.major = element_blank(), #Makes background theme white
                     panel.grid.minor = element_blank(), axis.line = element_blank()) +
  theme(axis.text = element_text(size = 11 , color = "black"),
        axis.title = element_text(size = 16, color = "black"), 
        axis.text.x = element_text(size=11, color="black"), 
        legend.title=element_blank(), 
        legend.text=element_text(color="black", size=12)); expression_plots

ggsave(filename="Mcap2020/Figures/Metabolomics/WGCNA/expression_eigengene.jpeg", plot=expression_plots, dpi=300, width=12, height=8, units="in")

head(mME_meta)

```

Output eigengene values to a data frame.  

```{r}
write.csv(mME_meta, "Mcap2020/Output/Metabolomics/WGCNA/module_expression.csv")
```

Add pattern names to each cluster. Cluster 1 = peaking in mid development; Cluster 2 = increasing; Cluster 3 = decreasing.  

```{r}
mME_meta<-mME_meta%>%
  mutate(pattern=if_else(Cluster=="Cluster1", "Mid", 
                         if_else(Cluster=="Cluster2", "Increasing", 
                                 if_else(Cluster=="Cluster3", "Decreasing", "NA"))))
mME_meta$pattern<-factor(mME_meta$pattern, levels=c("Decreasing", "Mid", "Increasing"))
```

Display the number of metabolites and modules in each cluster.  
```{r}
mME_meta%>%
  group_by(pattern)%>%
  summarise(module=length(unique(Module)))
```

There are 3 modules in each ontogenetic pattern. 

Number of metabolites (from above): 
Cluster 1 = 53 metabolites
Cluster 2 = 41 metabolites
Cluster 3 = 88 metabolites 


Plot by time point with module clusters.  
```{r}
mME_meta$group <- factor(mME_meta$group, levels = c("Egg", "Embryo", "Larvae", "Metamorphosed Polyp", "Attached Recruit"))
mME_meta$Cluster <- factor(mME_meta$Cluster, levels = c("Cluster1", "Cluster2", "Cluster3"))
mME_meta$lifestage <- factor(mME_meta$lifestage, levels = c("Egg (1 hpf)", "Embryo (5 hpf)", "Embryo (38 hpf)", "Embryo (65 hpf)", "Larvae (93 hpf) ", "Larvae (163 hpf)", "Larvae (183 hpf)", "Larvae (231 hpf) ", "Metamorphosed Polyp (183 hpf)", "Metamorphosed Polyp (231 hpf)", "Attached Recruit (183 hpf) ", "Attached Recruit (231 hpf)", "Attached Recruit (255 hpf)"))

expression_plots_cluster<-mME_meta%>%
#  group_by(Module) %>%
  ggplot(aes(x=lifestage, y=value)) +
  facet_grid(~pattern)+
  ylab("Eigengene Expression") +
  geom_hline(yintercept = 0, linetype="dashed", color = "grey")+
  geom_point(aes(fill=group, color=group), size=3, pch = 21, position = position_dodge(width = 0.5)) +
  geom_smooth(aes(group=1), se=TRUE, show.legend = NA, color="black")+
  scale_fill_manual(name="Lifestage", values=c("#8C510A", "#DFC27D","#80CDC1", "#003C30", "#BA55D3")) +
  scale_color_manual(name="Lifestage", values=c("#8C510A", "#DFC27D","#80CDC1", "#003C30", "#BA55D3")) +
  xlab("") + #Axis titles
  theme_bw() + theme(panel.border = element_rect(color="black", fill=NA, size=0.75), panel.grid.major = element_blank(), #Makes background theme white
                     panel.grid.minor = element_blank(), axis.line = element_blank()) +
  theme(axis.text = element_text(size = 11 , color = "black"),
        axis.title = element_text(size = 16, color = "black", face="bold"), 
        axis.text.x = element_blank(), 
        legend.position="bottom", 
        legend.title=element_text(size=12, face="bold"), 
        legend.text=element_text(color="black", size=12), 
        strip.text.x = element_text(size = 14, color = "black", face="bold"), 
        strip.background = element_rect(color="white", fill="white")); expression_plots_cluster

ggsave(filename="Mcap2020/Figures/Metabolomics/WGCNA/expression_eigengene_cluster.jpeg", plot=expression_plots_cluster, dpi=300, width=10, height=5, units="in")
ggsave(filename="Mcap2020/Figures/Metabolomics/WGCNA/expression_eigengene_cluster.pdf", plot=expression_plots_cluster, dpi=300, width=10, height=5, units="in")
``` 

Calculate relative change in expression for each of these three patterns relative to the first time point (eggs).    
```{r}
library(tidyverse)

metab_rel_change<-mME_meta%>%
  select(lifestage, Sample.ID, pattern, value)%>%
  group_by(lifestage, pattern)%>%
  summarise(mean=mean(value))%>% #calculate means
  group_by(lifestage, pattern)%>%
  arrange(lifestage, .by_group = TRUE)%>%
  group_by(pattern)%>%
  mutate(metabolite_expression=((mean-dplyr::first(mean))/abs(dplyr::first(mean))))%>%
  select(pattern, lifestage, metabolite_expression)%>%
  write_csv("Mcap2020/Data/Integration/RelativeChange/metabolites_relchange.csv")
```

# 5. Pathway Analysis  

Conduct pathway analysis for each module cluster - clusters 1 (Mid), 2 (Increasing), and 3 (Decreasing) as determined by WGCNA analysis above.  

First, generate a list of metabolites contained within each module cluster.  

```{r, echo=TRUE, warning=FALSE, message=FALSE}

module_df <- read.csv("Mcap2020/Output/Metabolomics/WGCNA/metabolite_modules.csv")

module_df <- module_df %>% rename(Module = colors)

# Select metabolites for each module 
cluster1<-c("2", "5", "0")
cluster2<-c("7", "6", "3")
cluster3<-c("1", "8", "4")

module_cluster1 <- module_df %>% filter(Module %in% cluster1)  %>% dplyr::select(Metabolite)
module_cluster2 <- module_df %>% filter(Module %in% cluster2)  %>% dplyr::select(Metabolite)
module_cluster3 <- module_df %>% filter(Module %in% cluster3)  %>% dplyr::select(Metabolite)

#output to files for use
write_csv(module_cluster1, file="Mcap2020/Output/Metabolomics/Metaboanalyst/cluster1_metabolite_list.csv")
write_csv(module_cluster2, file="Mcap2020/Output/Metabolomics/Metaboanalyst/cluster2_metabolite_list.csv")
write_csv(module_cluster3, file="Mcap2020/Output/Metabolomics/Metaboanalyst/cluster3_metabolite_list.csv")

dim(module_cluster1)
dim(module_cluster2)
dim(module_cluster3)
```

Cluster 1 = 53 metabolites
Cluster 2 = 41 metabolites
Cluster 3 = 88 metabolites 

Conducting analysis in MetaboAnalyst interface.  

*Note that Montiporic Acid A, B, C, and D are present in module clusters 2 but are not able to be used in the analysis since they are not in the reference database.*  

## 1. Enrichment compound class analysis - what types of compounds are enriched? 

https://www.metaboanalyst.ca/MetaboAnalyst/upload/EnrichUploadView.xhtml

Enrichment analysis - Main class chemical structures 

Loaded list of each module metabolites generated above (name is cluster#_metabolite_list.csv) and corrected metabolite names to match in database. 
Output table .csv of results saved to Mcap2020/Output/Metabolomics/Metaboanalyst folder.  

*CLUSTER 1*  
Modifications to chemical names were as follows (listed as original followed by Metaboanalyst corrected version):  
1-Methylimidazole acetic acid         Methylimidazole acetic acid  
3-Indo-L-tyrosine                     Iodotyrosine  
Acetyl glycine                        Phenylacetylglycine    
Arginine-Valine                       Arginyl-Valine    
Glutaryl-carnitine                    Glutamylarginine   
Methylphenyllactate                   3-Methylphenylacetic acid  
N-carbomoyl-L-aspartate               Ureidosuccinic acid  
NG-dimethyl-L-arginine                Asymmetric dimethylarginine  
Ribose phosphate                      Ribose 1-phosphate   

*CLUSTER 2*  
Modifications to chemical names were as follows (listed as original followed by Metaboanalyst corrected version):  
Cresol                                p-Cresol
Lysine-Glutamine                      Lysyl-Glutamine
N-Acetyl-Glucosamine                  N-Acetyl-D-Glucosamine 6-Phosphate

Montiporic Acid A-D (enriched but no match in database, not used in analysis)  

*CLUSTER 3*  
2-Furoyl glycine                      2-Furoylglycine                      
5- Methylthioadenosine                5'-Methylthioadenosine    
Acetyl-arginine                       N-a-Acetyl-L-arginine  
Alanine-Alanine                       Alanyl-Alanine    
Arginine-Alanine                      Arginyl-Alanine  
Arginine-Glutamine                    Arginyl-Glutamine  
N N N-Trimethyllysine                 N6,N6,N6-Trimethyl-L-lysine    
N-acetyl-L-ornithine                  N-Acetylornithine  
Ophthalmate                           Ophthalmic acid  

## 2. Pathway analysis - what metabolic pathways are enriched?  

https://www.metaboanalyst.ca/MetaboAnalyst/upload/EnrichUploadView.xhtml

Enrichment analysis - KEGG Pathway based analysis.  

Loaded list of each module metabolites (cluster#_metabolite_list.csv) and corrected names to match in database as specified above. KEGG enrichment analysis. Output results .csv to Output/Metabolmoics/Metaboanalyst

## 3. View results  

From these lists, we can identify the pathways that are significantly enriched (FDR < 0.05).   

### KEGG Pathways  

Load data output from Metaboanalyst and join into a single dataframe.    

```{r}
cluster1_kegg<-read.csv("Mcap2020/Output/Metabolomics/Metaboanalyst/Cluster1_KEGG.csv")
cluster1_kegg$Cluster<-"Cluster1"

cluster2_kegg<-read.csv("Mcap2020/Output/Metabolomics/Metaboanalyst/Cluster2_KEGG.csv")
cluster2_kegg$Cluster<-"Cluster2"

cluster3_kegg<-read.csv("Mcap2020/Output/Metabolomics/Metaboanalyst/Cluster3_KEGG.csv")
cluster3_kegg$Cluster<-"Cluster3"

kegg_pathways<-rbind(cluster1_kegg, cluster2_kegg, cluster3_kegg)
```

Filter out pathways that are significantly enriched with FDR p value <0.05.  

```{r}
sig_pathways<-kegg_pathways%>%
  filter(FDR<0.05)%>%
  dplyr::select(Metabolite.Set, Total, Hits, FDR, Cluster)%>%
  write.csv("Mcap2020/Output/Metabolomics/Metaboanalyst/KEGG_sign_pathways.csv")

sig_pathways<-kegg_pathways%>%
  filter(FDR<0.05)%>%
  dplyr::select(Metabolite.Set, Total, Hits, FDR, Cluster)%>%
  mutate(Group=if_else(Cluster=="Cluster1", "Larvae & Metamorphosed Polyps", "NA"))%>%
  mutate(Group=if_else(Cluster=="Cluster2", "Attached Recruits", Group))%>%
  mutate(Group=if_else(Cluster=="Cluster3", "Eggs & Embryos", Group))
```

Add pattern names to each cluster. Cluster 1 = peaking in mid development; Cluster 2 = increasing; Cluster 3 = decreasing.  

```{r}
sig_pathways<-sig_pathways%>%
  mutate(pattern=if_else(Cluster=="Cluster1", "Mid", 
                         if_else(Cluster=="Cluster2", "Increasing", 
                                 if_else(Cluster=="Cluster3", "Decreasing", "NA"))))
sig_pathways$pattern<-factor(sig_pathways$pattern, levels=c("Decreasing", "Mid", "Increasing"))
```

Plot these pathways with a dot plot across lifestage groupings.    

```{r}
#plot significantly enriched terms by ontogenetic pattern 
Pathways.Dot.Plot <-  ggplot(sig_pathways, aes(x = pattern, y = Metabolite.Set)) + 
  geom_point(aes(colour=FDR, size=Hits)) +
  #scale_color_continuous(name="FDR p-value", type = "gradient")+
  scale_color_distiller(type = "seq",
                        direction = -1,
                        palette = "Greys")+
  scale_size(range=c(4,10), limits=c(1,25))+
  guides(colour = guide_legend(override.aes = list(size=10)))+
  xlab("Ontogenetic Pattern")+
  ylab("KEGG Pathway")+
  theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"),
  strip.text.y = element_text(angle=0, size = 14, face="bold"),
  strip.background = element_rect(fill="white"), 
  axis.text.y = element_text(size = 12),
  axis.text.x = element_text(angle=35, size=12, hjust=1),
  axis.title.x = element_text(size = 14, face="bold"),
  axis.title.y = element_text(size = 14, face="bold"), 
  legend.text = element_text(size=14), 
  legend.title = element_text(size=12, face="bold"), 
  legend.key.size = unit(0.2, 'cm'));Pathways.Dot.Plot

ggsave(filename="Mcap2020/Figures/Metabolomics/WGCNA/pathways_dot_plot.png", plot=Pathways.Dot.Plot, dpi=300, width=8, height=6, units="in")

ggsave(filename="Mcap2020/Figures/Metabolomics/WGCNA/pathways_dot_plot.pdf", plot=Pathways.Dot.Plot, dpi=300, width=8, height=6, units="in")

```

### Compound Classes   

Load data output from Metaboanalyst and join into a single dataframe.    

```{r}
cluster1_class<-read.csv("Mcap2020/Output/Metabolomics/Metaboanalyst/Cluster1_Enrichment.csv")
cluster1_class$Cluster<-"Cluster1"

cluster2_class<-read.csv("Mcap2020/Output/Metabolomics/Metaboanalyst/Cluster2_Enrichment.csv")
cluster2_class$Cluster<-"Cluster2"

cluster3_class<-read.csv("Mcap2020/Output/Metabolomics/Metaboanalyst/Cluster3_Enrichment.csv")
cluster3_class$Cluster<-"Cluster3"

compound_classes<-rbind(cluster1_class, cluster2_class, cluster3_class)
```

Filter out pathways that are significantly enriched with FDR p value <0.05.  

```{r}
sig_classes_comp<-compound_classes%>%
  filter(FDR<0.05)%>%
  dplyr::select(Metabolite.Set, Total, Hits, FDR, Cluster)%>%
  write.csv("Mcap2020/Output/Metabolomics/Metaboanalyst/compound_sign_classes.csv")

sig_classes_comp<-compound_classes%>%
  filter(FDR<0.05)%>%
  dplyr::select(Metabolite.Set, Total, Hits, FDR, Cluster)%>%
  mutate(Group=if_else(Cluster=="Cluster1", "Larvae & Metamorphosed Polyps", "NA"))%>%
  mutate(Group=if_else(Cluster=="Cluster2", "Attached Recruits", Group))%>%
  mutate(Group=if_else(Cluster=="Cluster3", "Eggs & Embryos", Group))
  
```

Add pattern names to each cluster. Cluster 1 = peaking in mid development; Cluster 2 = increasing; Cluster 3 = decreasing.  

```{r}
sig_classes_comp<-sig_classes_comp%>%
  mutate(pattern=if_else(Cluster=="Cluster1", "Mid", 
                         if_else(Cluster=="Cluster2", "Increasing", 
                                 if_else(Cluster=="Cluster3", "Decreasing", "NA"))))
sig_classes_comp$pattern<-factor(sig_classes_comp$pattern, levels=c("Decreasing", "Mid", "Increasing"))
```

Plot these pathways with a dot plot across lifestage groupings.    

```{r}
#plot significantly enriched terms by ontogenetic pattern 
Compounds.Dot.Plot <-  ggplot(sig_classes_comp, aes(x = pattern, y = Metabolite.Set)) + 
  geom_point(aes(colour=FDR, size=Hits)) +
  #scale_color_continuous(name="FDR p-value", type = "gradient")+
  scale_color_distiller(type = "seq",
                        direction = -1,
                        palette = "Greys")+
  scale_size(range=c(4,10), limits=c(1,25))+
  guides(colour = guide_legend(override.aes = list(size=10)))+
  xlab("Ontogenetic Pattern")+
  ylab("Compound Class")+
  theme_bw() + theme(panel.border = element_blank(), panel.grid.major = element_blank(),
  panel.grid.minor = element_blank(), axis.line = element_line(colour = "black"),
  strip.text.y = element_text(angle=0, size = 14, face="bold"),
  strip.background = element_rect(fill="white"), 
  axis.text.y = element_text(size = 12),
  axis.text.x = element_text(angle=35, size=12, hjust=1),
  axis.title.x = element_text(size = 14, face="bold"),
  axis.title.y = element_text(size = 14, face="bold"), 
  legend.text = element_text(size=12), 
  legend.title = element_text(size=14, face="bold"), 
  legend.key.size = unit(0.2, 'cm'));Compounds.Dot.Plot

ggsave(filename="Mcap2020/Figures/Metabolomics/WGCNA/compounds_dot_plot.png", plot=Compounds.Dot.Plot, dpi=300, width=8, height=6, units="in")
ggsave(filename="Mcap2020/Figures/Metabolomics/WGCNA/compounds_dot_plot.pdf", plot=Compounds.Dot.Plot, dpi=300, width=8, height=6, units="in")
```
