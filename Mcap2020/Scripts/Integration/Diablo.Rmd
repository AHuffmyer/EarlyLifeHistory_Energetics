---
title: "Integration"
author: "AS Huffmyer"
output:
  html_document:
    toc: yes
    toc_depth: 6
    toc_float: yes
  pdf_document:
    keep_tex: yes
editor_options: 
  chunk_output_type: console
---

Run trial of Diablo scripts for genes and metabolomics. 

Trialing first with genes and metabolites, since these are already normalized.  NEXT STEP: Run with 16S data.  

# **Setup**  

Set up workspace, set options, and load required packages.    
```{r}
knitr::opts_chunk$set(echo = TRUE, warning = FALSE, message = FALSE)
```

```{r setup, include = FALSE}
## install packages if you dont already have them
if (!require("tidyverse")) install.packages("tidyverse")
if (!require("ggplot2")) install.packages("ggplot2")
if (!require("janitor")) install.packages("janitor")
if (!require("mixOmics")) install.packages("mixOmics")
if (!require("genefilter")) install.packages("genefilter")
if (!require("DESeq2")) install.packages("DESeq2")

# load packages
library(ggplot2)
library(corpcor)
library(janitor)
library(mixOmics)
library(tidyverse)
library(genefilter)
library(DESeq2)

```

# **Metabolomics SPLSDA**  

We need to load data to have samples in rows and features in columns. We are not yet summarizing by lifestage, we will perform individual SPLSDA analyses on each full dataset to obtain keepX optimization.  

Metadata 
```{r}
metadata<-read.csv("Mcap2020/Data/lifestage_metadata.csv")

genes_metadata <- read.csv("Mcap2020/Data/TagSeq/Sample_Info.csv", header = TRUE, sep = ",")
head(genes_metadata)
```

Metabolomics
```{r}
metabolomics<-read.csv("Mcap2020/Data/Integration/selected_metabolites.csv")

metabolomics<-metabolomics%>%
  mutate(Sample=paste(Lifestage, Rep))%>%
  dplyr::select(Sample, Lifestage, compound, norm_counts)%>%
  spread(compound, norm_counts)

metabolomics<-as.data.frame(metabolomics)

```

Create PLSDA
```{r}
#assigning datasets 
X <- metabolomics[3:184]

Y <- as.factor(metabolomics$Lifestage) #select treatment names
Y

MyResult.plsda_metab <- plsda(X,Y, ncomp=9) #number of components is classes-1

#MyResult.splsda_metab <- splsda(X,Y, ncomp=12) #number of components is classes-1

plotIndiv(MyResult.plsda_metab) 
```

Run SPLSDA to tune parameters

Plot errors
```{r}

MyPerf.plsda_metab <- perf(MyResult.plsda_metab, validation = "Mfold", folds=4, #fold #? 
                     progressBar = TRUE, nrepeat = 20) # we suggest nrepeat = 50

plot(MyPerf.plsda_metab,  sd = TRUE)
```

Determine keepX
```{r}
#now run tune splsda 
list.keepX <- c(2:10,  seq(20, 300, 10))

set.seed(30) # for reproducbility in this vignette, otherwise increase nrepeat
tune.splsda.srbct <- tune.splsda(X, Y, ncomp = 9, 
                                 validation = 'Mfold', folds=4,
                                 measure = "BER", test.keepX = list.keepX, nrepeat=20)   # we suggest nrepeat = 50

error <- tune.splsda.srbct$error.rate
ncomp.metab <- tune.splsda.srbct$choice.ncomp$ncomp # optimal number of components based on t-tests on the error rate
ncomp.metab

select.keepX.metab <- tune.splsda.srbct$choice.keepX# optimal number of variables to select
select.keepX.metab

plot(tune.splsda.srbct)
```

The optimal number of components is ncomp=8 with keepX=110 features. 

comp1 comp2 comp3 comp4 comp5 comp6 comp7 comp8 comp9 
    2     3    10     5   140     2     3   110     8 

# **Gene SPLSDA**  

We need to load data to have samples in rows and features in columns. We are not yet summarizing by lifestage, we will perform individual SPLSDA analyses on each full dataset to obtain keepX optimization.  

Load data   
```{r}
genes<-read.csv("Mcap2020/Output/TagSeq/transformed_filtered_genes.csv") 

nrow(genes)
#15797 genes 

rownames(genes)<-genes$X

genes<-genes[-c(1)]

#transpose to have samples in rows and genes in columns
dim(genes)

genes_t<-t(genes)

dim(genes_t)

rownames(genes_t)
```


```{r}
#correct for lifestage names to match metabolomics
genes_t<-as.data.frame(genes_t)
dim(genes_t)

genes_t$Lifestage<-genes_metadata$code[match(rownames(genes_t), genes_metadata$sample_id)]
dim(genes_t)

#summarize gene counts for each lifestage
gene_data<-genes_t%>%
  relocate(Lifestage) #%>%
  #group_by(Lifestage)%>%
  #summarise_at(vars(2:15797), mean, na.rm = TRUE)

#finally make the lifestage the row names
gene_data<-as.data.frame(gene_data)

#rownames(gene_data)<-gene_data$Lifestage

gene_data<-gene_data%>%
  dplyr::select(!Lifestage)

dim(gene_data)

```

Create PLSDA
```{r}
#assigning datasets 
X <- gene_data[2:15798]

Y <- as.factor(gene_data$Lifestage) #select treatment names
Y

MyResult.plsda_gene <- plsda(X,Y, ncomp=9) #number of components is classes-1

plotIndiv(MyResult.plsda_gene) 
```

Run SPLSDA to tune parameters

Plot errors
```{r}

MyPerf.plsda_gene <- perf(MyResult.plsda_gene, validation = "Mfold", folds=3, #fold #? 
                     progressBar = TRUE, nrepeat = 10) # we suggest nrepeat = 50

plot(MyPerf.plsda_gene,  sd = TRUE)
```

Determine keepX
```{r}
#now run tune splsda 
list.keepX <- c(2:10,  seq(20, 300, 10))

set.seed(30) # for reproducbility in this vignette, otherwise increase nrepeat
tune.splsda.srbct_gene <- tune.splsda(X, Y, ncomp = 9, 
                                 validation = 'Mfold', folds=3,
                                 measure = "BER", test.keepX = list.keepX, nrepeat=20)   # we suggest nrepeat = 50

error <- tune.splsda.srbct_gene$error.rate
ncomp.gene <- tune.splsda.srbct_gene$choice.ncomp$ncomp # optimal number of components based on t-tests on the error rate
ncomp.gene

select.keepX.gene <- tune.splsda.srbct_gene$choice.keepX# optimal number of variables to select
select.keepX.gene

plot(tune.splsda.srbct_gene)
```

The optimal number of components is ncomp=8 and keepX=270.  

comp1 comp2 comp3 comp4 comp5 comp6 comp7 comp8 comp9 
    2    10     2     3   300   300   140   270   220
    
# **Load data for DIABLO**  

We need to load data to have samples in rows and features in columns. 

We will calculate averages for each dataframe for each timepoint.  

Metadata 
```{r}
metadata<-read.csv("Mcap2020/Data/lifestage_metadata.csv")

genes_metadata <- read.csv("Mcap2020/Data/TagSeq/Sample_Info.csv", header = TRUE, sep = ",")
head(genes_metadata)
```

Metabolomics
```{r}
metabolomics<-read.csv("Mcap2020/Data/Integration/selected_metabolites.csv")

metabolomics<-metabolomics%>%
  dplyr::select(Lifestage, compound, norm_counts)%>%
  group_by(Lifestage, compound)%>%
  summarise(metab=mean(norm_counts))%>%
  spread(compound, metab)

metabolomics<-as.data.frame(metabolomics)

rownames(metabolomics)<-metabolomics$Lifestage #set row names 

metabolomics<-metabolomics[-c(1)]
```

Gene expression 
```{r}
genes<-read.csv("Mcap2020/Output/TagSeq/transformed_filtered_genes.csv") 

nrow(genes)
#15797 genes 

rownames(genes)<-genes$X

genes<-genes[-c(1)]

#transpose to have samples in rows and genes in columns
dim(genes)

genes_t<-t(genes)

dim(genes_t)

rownames(genes_t)
```


```{r}
#correct for lifestage names to match metabolomics
genes_t<-as.data.frame(genes_t)
dim(genes_t)

genes_t$Lifestage<-genes_metadata$code[match(rownames(genes_t), genes_metadata$sample_id)]
dim(genes_t)

#summarize gene counts for each lifestage
gene_data<-genes_t%>%
  relocate(Lifestage)%>%
  group_by(Lifestage)%>%
  summarise_at(vars(2:15797), mean, na.rm = TRUE)

#finally make the lifestage the row names
gene_data<-as.data.frame(gene_data)

rownames(gene_data)<-gene_data$Lifestage

gene_data<-gene_data%>%
  dplyr::select(!Lifestage)

dim(gene_data)
```


# **Generate multivariate PLSDA**  

Plotting all stages together.  

Assemble dataframe  
```{r}
#filter metabolite data by the lifestages available in genes 
groups<-rownames(gene_data)

metabolomics<-metabolomics%>%
  filter(rownames(.) %in% groups)

#larvae_list<-c("Larvae1", "Larvae2", "Larvae3", "Larvae4", "Larvae6")

#genes_larvae<-gene_data%>%
  #filter(rownames(.) %in% larvae_list)

#metab_larvae<-metabolomics%>%
  #filter(rownames(.) %in% larvae_list)


X <- list(genes = gene_data, # all rows are samples, columns are compounds/genes
          metabolites = metabolomics)
Y <- rownames(gene_data)
summary(Y)

```

Specify test values.  This is generated from the splsda above.  
```{r}
list.keepX <- list(genes = c(270,270), metabolites = c(110,110))
```

GENES: 
comp1 comp2 comp3 comp4 comp5 comp6 comp7 comp8 comp9 
    2    10     2     3   300   300   140   270   220
    
METABOLITES: 
comp1 comp2 comp3 comp4 comp5 comp6 comp7 comp8 comp9 
    2     3    10     5   140     2     3   110     8     
    
How does the number of comps change our output? 
    
Run PLSDA
```{r}
MyResult.diablo <- block.splsda(X, Y, keepX=list.keepX, ncomp=2)
plotIndiv(MyResult.diablo) ## sample plot
#plotVar(MyResult.diablo) ## variable plot

```

Plot circos plot  

```{r}
#circos plot
circosPlot(MyResult.diablo, cutoff=0.95, line = TRUE, showIntraLinks=FALSE, color.cor=c("red", "white"))

cor_mat<-circosPlot(MyResult.diablo, cutoff=0.95)

```

Output plot and correlation matrix.  
```{r}
pdf("Mcap2020/Figures/Integration/circos0.90.pdf", width=12, height=12)
circosPlot(MyResult.diablo, cutoff=0.90, line = TRUE, showIntraLinks=FALSE, color.cor=c("red", "white"))
dev.off()
```

Export correlation matrix.  
```{r}
test<-cor_mat

test[test <0.90]<-NA
  
write.csv(test, "Mcap2020/Output/Integration/cor_circos_0.90.csv")
```

Ground-truthing some of our correlations: 

For example, the metabolite FAD is positively correlated with 
- g56275 (hydrolase activity) * this is expected since it is a hydrolase enzyme
- g28147	
- g68777
- g49267 (rRNA (guanine) methyltransferase activity; rRNA (guanine-N7)-methylation;NA) *this makes sense! FAD dependent methyltransferase
- g26427 (protein binding;NA) *this makes sense, its an enzyme 

Methionine sulfoxide is positively correlated with
- g11665
- g41679 (extracellular matrix structural constituent;NA) * makes sense, involved in structure/membranes 
- g46335 (extracellular matrix structural constituent;NA)
- g52872 (serine-type endopeptidase inhibitor activity; insulin-like growth factor binding; extracellular region;NA) 

NAD+ is correlated with 
- g49267 (rRNA (guanine) methyltransferase activity; rRNA (guanine-N7)-methylation;NA) *plays a role in methylation

Acetyl CoA correlated with: 
- g38364 (DNA binding, regulation of transcription) *acetyl coa can stimulate transcription, makes sense 


Plot heatmap  
```{r}
library(pheatmap)

pheatmap::pheatmap(cor_mat, cluster_rows = TRUE, cluster_cols = TRUE, show_rownames = FALSE, show_colnames = FALSE)
```

Plot cim plot  
```{r}
cimDiablo(MyResult.diablo, margin=c(8,8), legend.position = "none", comp = c(1,2), trim=2)

pdf("Mcap2020/Figures/Integration/cim_plot.pdf", height=8, width=8)
cimDiablo(MyResult.diablo, margin=c(8,8), legend.position = "none", comp = c(1,2), trim=2)
dev.off()

res <- cimDiablo(MyResult.diablo) ## save the output
res_mat<-res$mat
#can use this to pull out correlations with groups (this is super great!)

write.csv(res_mat, "Mcap2020/Output/Integration/cim_matrix.csv")
```

What are the numeric values? It doesn't seem to be true correlation values (outside range of 1). Default is trimming to 3 standard deviations - of what? 

We think it might be euclidian distances as a distance matrix. How do we want to choose our cut offs?  


NEXT STEP: Trial adding in 16S data  


OUTSTANDING QUESTIONS: 
- How do ncomp and keepX relate to each other and how do we pick ncomp/keepX? 
- How do we get to functional information about what things are correlated? 
- Can we do 3-way correlations or multi omic correlations?  

THINGS WE WANT TO SAY: 
- What omic is driving differences? 
- How connected are they together? 
- What functions are correlated to each other?